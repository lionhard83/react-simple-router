{
  "manifest": {
    "author": {
      "name": "Gajus Kuizinas",
      "email": "gajus@gajus.com",
      "url": "http://gajus.com"
    },
    "dependencies": {
      "lodash": "^4.17.21",
      "string-natural-compare": "^3.0.1"
    },
    "description": "Flowtype linting rules for ESLint.",
    "devDependencies": {
      "@babel/cli": "^7.15.7",
      "@babel/core": "^7.15.8",
      "@babel/eslint-parser": "^7.15.8",
      "@babel/node": "^7.15.8",
      "@babel/plugin-proposal-object-rest-spread": "^7.15.6",
      "@babel/plugin-syntax-flow": "^7.14.5",
      "@babel/plugin-transform-react-jsx": "^7.14.9",
      "@babel/preset-env": "^7.15.8",
      "@babel/register": "^7.15.3",
      "ajv": "^8.6.3",
      "babel-plugin-add-module-exports": "^1.0.4",
      "eslint": "^8.1.0",
      "eslint-config-canonical": "^32.15.0",
      "eslint-plugin-eslint-plugin": "^4.0.2",
      "gitdown": "^3.1.4",
      "glob": "^7.2.0",
      "husky": "^7.0.4",
      "jsonlint": "^1.6.3",
      "mocha": "^9.1.3",
      "rimraf": "^3.0.2",
      "semantic-release": "^18.0.0"
    },
    "engines": {
      "node": ">=12.0.0"
    },
    "husky": {
      "hooks": {
        "pre-commit": "npm run check-docs && npm run check-tests && npm run lint && npm run test && npm run build && npm run format-json"
      }
    },
    "keywords": [
      "eslint",
      "plugin",
      "flowtype"
    ],
    "license": "BSD-3-Clause",
    "main": "./dist/index.js",
    "name": "eslint-plugin-flowtype",
    "peerDependencies": {
      "@babel/plugin-syntax-flow": "^7.14.5",
      "@babel/plugin-transform-react-jsx": "^7.14.9",
      "eslint": "^8.1.0"
    },
    "repository": {
      "type": "git",
      "url": "https://github.com/gajus/eslint-plugin-flowtype"
    },
    "scripts": {
      "build": "rimraf ./dist && babel ./src --out-dir ./dist --copy-files",
      "check-docs": "babel-node ./src/bin/checkDocs",
      "check-tests": "babel-node ./src/bin/checkTests",
      "create-readme": "gitdown ./.README/README.md --output-file ./README.md && npm run documentation-add-assertions",
      "documentation-add-assertions": "babel-node ./src/bin/addAssertions",
      "format-json": "jsonlint --sort-keys --in-place --indent \"  \" ./src/configs/recommended.json",
      "lint": "eslint ./src ./tests",
      "test": "mocha --require @babel/register ./tests/rules/index.js"
    },
    "version": "8.0.3",
    "_registry": "npm",
    "_loc": "/Users/carloleonardi/Documents/workspace/React/sample-routing/@mui/material/v6/npm-eslint-plugin-flowtype-8.0.3-e1557e37118f24734aa3122e7536a038d34a4912-integrity/node_modules/eslint-plugin-flowtype/package.json",
    "readmeFilename": "README.md",
    "readme": "<a name=\"eslint-plugin-flowtype\"></a>\n# eslint-plugin-flowtype\n\n[![NPM version](http://img.shields.io/npm/v/eslint-plugin-flowtype.svg?style=flat-square)](https://www.npmjs.org/package/eslint-plugin-flowtype)\n[![Travis build status](http://img.shields.io/travis/gajus/eslint-plugin-flowtype/master.svg?style=flat-square)](https://travis-ci.com/github/gajus/eslint-plugin-flowtype)\n[![js-canonical-style](https://img.shields.io/badge/code%20style-canonical-blue.svg?style=flat-square)](https://github.com/gajus/canonical)\n\n[Flow type](http://flowtype.org/) linting rules for ESLint.\n\n* [eslint-plugin-flowtype](#eslint-plugin-flowtype)\n    * [Installation](#eslint-plugin-flowtype-installation)\n    * [Configuration](#eslint-plugin-flowtype-configuration)\n        * [Shareable configurations](#eslint-plugin-flowtype-configuration-shareable-configurations)\n        * [Community maintained configurations](#eslint-plugin-flowtype-configuration-community-maintained-configurations)\n    * [Settings](#eslint-plugin-flowtype-settings)\n        * [`onlyFilesWithFlowAnnotation`](#eslint-plugin-flowtype-settings-onlyfileswithflowannotation)\n    * [Rules](#eslint-plugin-flowtype-rules)\n        * [`array-style-complex-type`](#eslint-plugin-flowtype-rules-array-style-complex-type)\n        * [`array-style-simple-type`](#eslint-plugin-flowtype-rules-array-style-simple-type)\n        * [`arrow-parens`](#eslint-plugin-flowtype-rules-arrow-parens)\n        * [`boolean-style`](#eslint-plugin-flowtype-rules-boolean-style)\n        * [`define-flow-type`](#eslint-plugin-flowtype-rules-define-flow-type)\n        * [`delimiter-dangle`](#eslint-plugin-flowtype-rules-delimiter-dangle)\n        * [`enforce-line-break`](#eslint-plugin-flowtype-rules-enforce-line-break)\n        * [`generic-spacing`](#eslint-plugin-flowtype-rules-generic-spacing)\n        * [`interface-id-match`](#eslint-plugin-flowtype-rules-interface-id-match)\n        * [`newline-after-flow-annotation`](#eslint-plugin-flowtype-rules-newline-after-flow-annotation)\n        * [`no-dupe-keys`](#eslint-plugin-flowtype-rules-no-dupe-keys)\n        * [`no-duplicate-type-union-intersection-members`](#eslint-plugin-flowtype-rules-no-duplicate-type-union-intersection-members)\n        * [`no-existential-type`](#eslint-plugin-flowtype-rules-no-existential-type)\n        * [`no-flow-fix-me-comments`](#eslint-plugin-flowtype-rules-no-flow-fix-me-comments)\n        * [`no-internal-flow-type`](#eslint-plugin-flowtype-rules-no-internal-flow-type)\n        * [`no-mixed`](#eslint-plugin-flowtype-rules-no-mixed)\n        * [`no-mutable-array`](#eslint-plugin-flowtype-rules-no-mutable-array)\n        * [`no-primitive-constructor-types`](#eslint-plugin-flowtype-rules-no-primitive-constructor-types)\n        * [`no-types-missing-file-annotation`](#eslint-plugin-flowtype-rules-no-types-missing-file-annotation)\n        * [`no-unused-expressions`](#eslint-plugin-flowtype-rules-no-unused-expressions)\n        * [`no-weak-types`](#eslint-plugin-flowtype-rules-no-weak-types)\n        * [`object-type-curly-spacing`](#eslint-plugin-flowtype-rules-object-type-curly-spacing)\n        * [`object-type-delimiter`](#eslint-plugin-flowtype-rules-object-type-delimiter)\n        * [`quotes`](#eslint-plugin-flowtype-rules-quotes)\n        * [`require-compound-type-alias`](#eslint-plugin-flowtype-rules-require-compound-type-alias)\n        * [`require-exact-type`](#eslint-plugin-flowtype-rules-require-exact-type)\n        * [`require-indexer-name`](#eslint-plugin-flowtype-rules-require-indexer-name)\n        * [`require-inexact-type`](#eslint-plugin-flowtype-rules-require-inexact-type)\n        * [`require-parameter-type`](#eslint-plugin-flowtype-rules-require-parameter-type)\n        * [`require-readonly-react-props`](#eslint-plugin-flowtype-rules-require-readonly-react-props)\n        * [`require-return-type`](#eslint-plugin-flowtype-rules-require-return-type)\n        * [`require-types-at-top`](#eslint-plugin-flowtype-rules-require-types-at-top)\n        * [`require-valid-file-annotation`](#eslint-plugin-flowtype-rules-require-valid-file-annotation)\n        * [`require-variable-type`](#eslint-plugin-flowtype-rules-require-variable-type)\n        * [`semi`](#eslint-plugin-flowtype-rules-semi)\n        * [`sort-keys`](#eslint-plugin-flowtype-rules-sort-keys)\n        * [`sort-type-union-intersection-members`](#eslint-plugin-flowtype-rules-sort-type-union-intersection-members)\n        * [`space-after-type-colon`](#eslint-plugin-flowtype-rules-space-after-type-colon)\n        * [`space-before-generic-bracket`](#eslint-plugin-flowtype-rules-space-before-generic-bracket)\n        * [`space-before-type-colon`](#eslint-plugin-flowtype-rules-space-before-type-colon)\n        * [`spread-exact-type`](#eslint-plugin-flowtype-rules-spread-exact-type)\n        * [`type-id-match`](#eslint-plugin-flowtype-rules-type-id-match)\n        * [`type-import-style`](#eslint-plugin-flowtype-rules-type-import-style)\n        * [`union-intersection-spacing`](#eslint-plugin-flowtype-rules-union-intersection-spacing)\n        * [`use-flow-type`](#eslint-plugin-flowtype-rules-use-flow-type)\n        * [`use-read-only-spread`](#eslint-plugin-flowtype-rules-use-read-only-spread)\n        * [`valid-syntax`](#eslint-plugin-flowtype-rules-valid-syntax)\n\n\n<a name=\"eslint-plugin-flowtype-installation\"></a>\n## Installation\n\n```bash\nnpm install eslint --save-dev\nnpm install @babel/eslint-parser --save-dev\nnpm install eslint-plugin-flowtype --save-dev\n```\n\n<a name=\"eslint-plugin-flowtype-configuration\"></a>\n## Configuration\n\n1. Set `parser` property to `@babel/eslint-parser`.\n1. Add `plugins` section and specify `eslint-plugin-flowtype` as a plugin.\n1. Enable rules.\n\n<!-- -->\n\n```json\n{\n  \"parser\": \"@babel/eslint-parser\",\n  \"plugins\": [\n    \"flowtype\"\n  ],\n  \"rules\": {\n    \"flowtype/boolean-style\": [\n      2,\n      \"boolean\"\n    ],\n    \"flowtype/define-flow-type\": 1,\n    \"flowtype/delimiter-dangle\": [\n      2,\n      \"never\"\n    ],\n    \"flowtype/generic-spacing\": [\n      2,\n      \"never\"\n    ],\n    \"flowtype/interface-id-match\": [\n      2,\n      \"^([A-Z][a-z0-9]+)+Type$\"\n    ],\n    \"flowtype/no-mixed\": 2,\n    \"flowtype/no-primitive-constructor-types\": 2,\n    \"flowtype/no-types-missing-file-annotation\": 2,\n    \"flowtype/no-weak-types\": 2,\n    \"flowtype/object-type-delimiter\": [\n      2,\n      \"comma\"\n    ],\n    \"flowtype/require-parameter-type\": 2,\n    \"flowtype/require-readonly-react-props\": 0,\n    \"flowtype/require-return-type\": [\n      2,\n      \"always\",\n      {\n        \"annotateUndefined\": \"never\"\n      }\n    ],\n    \"flowtype/require-valid-file-annotation\": 2,\n    \"flowtype/semi\": [\n      2,\n      \"always\"\n    ],\n    \"flowtype/space-after-type-colon\": [\n      2,\n      \"always\"\n    ],\n    \"flowtype/space-before-generic-bracket\": [\n      2,\n      \"never\"\n    ],\n    \"flowtype/space-before-type-colon\": [\n      2,\n      \"never\"\n    ],\n    \"flowtype/type-id-match\": [\n      2,\n      \"^([A-Z][a-z0-9]+)+Type$\"\n    ],\n    \"flowtype/union-intersection-spacing\": [\n      2,\n      \"always\"\n    ],\n    \"flowtype/use-flow-type\": 1,\n    \"flowtype/valid-syntax\": 1\n  },\n  \"settings\": {\n    \"flowtype\": {\n      \"onlyFilesWithFlowAnnotation\": false\n    }\n  }\n}\n```\n\n<a name=\"eslint-plugin-flowtype-configuration-shareable-configurations\"></a>\n### Shareable configurations\n\n<a name=\"eslint-plugin-flowtype-configuration-shareable-configurations-recommended\"></a>\n#### Recommended\n\nThis plugin exports a [recommended configuration](./src/configs/recommended.json) that enforces Flow type good practices.\n\nTo enable this configuration use the extends property in your `.eslintrc` config file:\n\n```json\n{\n  \"extends\": [\n    \"plugin:flowtype/recommended\"\n  ],\n  \"plugins\": [\n    \"flowtype\"\n  ]\n}\n```\n\nSee [ESLint documentation](http://eslint.org/docs/user-guide/configuring#extending-configuration-files) for more information about extending configuration files.\n\n<a name=\"eslint-plugin-flowtype-configuration-community-maintained-configurations\"></a>\n### Community maintained configurations\n\nThe following are third-party submitted/ maintained configurations of `eslint-plugin-flowtype`:\n\n* https://github.com/wemake-services/eslint-config-flowtype-essential\n\n<a name=\"eslint-plugin-flowtype-settings\"></a>\n## Settings\n\n<a name=\"eslint-plugin-flowtype-settings-onlyfileswithflowannotation\"></a>\n### <code>onlyFilesWithFlowAnnotation</code>\n\nWhen `true`, only checks files with a [`@flow` annotation](http://flowtype.org/docs/about-flow.html#gradual) in the first comment.\n\n```js\n{\n  \"settings\": {\n    \"flowtype\": {\n      \"onlyFilesWithFlowAnnotation\": true\n    }\n  }\n}\n```\n\n<a name=\"eslint-plugin-flowtype-rules\"></a>\n## Rules\n\n<!-- Rules are sorted alphabetically. -->\n\n<a name=\"eslint-plugin-flowtype-rules-array-style-complex-type\"></a>\n### <code>array-style-complex-type</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces a particular annotation style of complex types.\n\nType is considered complex in these cases:\n\n* [Maybe type](https://flow.org/en/docs/types/maybe/)\n* [Function type](https://flow.org/en/docs/types/functions/)\n* [Object type](https://flow.org/en/docs/types/objects/)\n* [Tuple type](https://flow.org/en/docs/types/tuples/)\n* [Union type](https://flow.org/en/docs/types/unions/)\n* [Intersection type](https://flow.org/en/docs/types/intersections/)\n\nThis rule takes one argument.\n\nIf it is `'verbose'` then a problem is raised when using `Type[]` instead of `Array<Type>`.\n\nIf it is `'shorthand'` then a problem is raised when using `Array<Type>` instead of `Type[]`.\n\nThe default value is `'verbose'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = (?string)[]\n// Message: Use \"Array<?string>\", not \"(?string)[]\"\n\n// Options: [\"verbose\"]\ntype X = (?string)[]\n// Message: Use \"Array<?string>\", not \"(?string)[]\"\n\n// Options: [\"shorthand\"]\ntype X = Array<?string>\n// Message: Use \"(?string)[]\", not \"Array<?string>\"\n\n// Options: [\"shorthand\"]\ntype X = Array<{foo: string}>\n// Message: Use \"{foo: string}[]\", not \"Array<{foo: string}>\"\n\ntype X = (string | number)[]\n// Message: Use \"Array<string | number>\", not \"(string | number)[]\"\n\ntype X = (string & number)[]\n// Message: Use \"Array<string & number>\", not \"(string & number)[]\"\n\ntype X = [string, number][]\n// Message: Use \"Array<[string, number]>\", not \"[string, number][]\"\n\ntype X = {foo: string}[]\n// Message: Use \"Array<{foo: string}>\", not \"{foo: string}[]\"\n\ntype X = (string => number)[]\n// Message: Use \"Array<string => number>\", not \"(string => number)[]\"\n\ntype X = {\n    foo: string,\n    bar: number\n}[]\n// Message: Use \"Array<{ foo: string, bar: number }>\", not \"{ foo: string, bar: number }[]\"\n\ntype X = {\n    foo: string,\n    bar: number,\n    quo: boolean,\n    hey: Date\n}[]\n// Message: Use \"Array<Type>\", not \"Type[]\"\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = Array<?string>\n\n// Options: [\"verbose\"]\ntype X = Array<?string>\n\n// Options: [\"shorthand\"]\ntype X = (?string)[]\n\n// Options: [\"shorthand\"]\ntype X = Array<string>\n\n// Options: [\"shorthand\"]\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype X = Array<?string>\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-array-style-simple-type\"></a>\n### <code>array-style-simple-type</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces a particular array type annotation style of simple types.\n\nType is considered simple in these cases:\n\n* [Primitive types](https://flow.org/en/docs/types/primitives/)\n* [Literal types](https://flow.org/en/docs/types/literals/)\n* [Mixed type](https://flow.org/en/docs/types/mixed/)\n* [Any type](https://flow.org/en/docs/types/any/)\n* [Class type](https://flow.org/en/docs/types/classes/)\n* [Generic type](https://flow.org/en/docs/types/generics/)\n* Array type [shorthand notation](https://flow.org/en/docs/types/arrays/#toc-array-type-shorthand-syntax)\n\nThis rule takes one argument.\n\nIf it is `'verbose'` then a problem is raised when using `Type[]` instead of `Array<Type>`.\n\nIf it is `'shorthand'` then a problem is raised when using `Array<Type>` instead of `Type[]`.\n\nThe default value is `'verbose'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = string[]\n// Message: Use \"Array<string>\", not \"string[]\"\n\n// Options: [\"verbose\"]\ntype X = string[]\n// Message: Use \"Array<string>\", not \"string[]\"\n\n// Options: [\"shorthand\"]\ntype X = Array<string>\n// Message: Use \"string[]\", not \"Array<string>\"\n\ntype X = Date[]\n// Message: Use \"Array<Date>\", not \"Date[]\"\n\ntype X = Promise<string>[]\n// Message: Use \"Array<Promise<string>>\", not \"Promise<string>[]\"\n\ntype X = $Keys<{foo: string}>[]\n// Message: Use \"Array<$Keys<{foo: string}>>\", not \"$Keys<{foo: string}>[]\"\n\ntype X = any[]\n// Message: Use \"Array<any>\", not \"any[]\"\n\ntype X = mixed[]\n// Message: Use \"Array<mixed>\", not \"mixed[]\"\n\ntype X = void[]\n// Message: Use \"Array<void>\", not \"void[]\"\n\ntype X = null[]\n// Message: Use \"Array<null>\", not \"null[]\"\n\ntype X = Promise<{\n    foo: string,\n    bar: number\n}>[]\n// Message: Use \"Array<Promise<{ foo: string, bar: number }>>\", not \"Promise<{ foo: string, bar: number }>[]\"\n\ntype X = Promise<{\n    foo: string,\n    bar: number,\n    quo: boolean\n}>[]\n// Message: Use \"Array<Type>\", not \"Type[]\"\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = Array<string>\n\n// Options: [\"verbose\"]\ntype X = Array<string>\n\n// Options: [\"shorthand\"]\ntype X = string[]\n\ntype X = Array<Array<string>>\n\n// Options: [\"verbose\"]\ntype X = (?string)[]\n\n// Options: [\"verbose\"]\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype X = string[]\n\ntype X = Array\n\ntype X = typeof Array\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-arrow-parens\"></a>\n### <code>arrow-parens</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces the consistent use of parentheses in arrow functions.\n\nThis rule has a string option and an object one.\n\nString options are:\n\n- `\"always\"` (default) requires parens around arguments in all cases.\n- `\"as-needed\"` enforces no braces where they can be omitted.\n\nObject properties for variants of the `\"as-needed\"` option:\n\n- `\"requireForBlockBody\": true` modifies the as-needed rule in order to require parens if the function body is in an instructions block (surrounded by braces).\n\nThe following patterns are considered problems:\n\n```js\na => {}\n// Message: undefined\n\na => a\n// Message: undefined\n\na => {\n}\n// Message: undefined\n\na.then(foo => {});\n// Message: undefined\n\na.then(foo => a);\n// Message: undefined\n\na(foo => { if (true) {}; });\n// Message: undefined\n\na(async foo => { if (true) {}; });\n// Message: undefined\n\n// Options: [\"as-needed\"]\n(a) => a\n// Message: undefined\n\n// Options: [\"as-needed\"]\n(a,) => a\n// Message: undefined\n\n// Options: [\"as-needed\"]\nasync (a) => a\n// Message: undefined\n\n// Options: [\"as-needed\"]\nasync(a) => a\n// Message: undefined\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\na => {}\n// Message: undefined\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n(a) => a\n// Message: undefined\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\nasync a => {}\n// Message: undefined\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\nasync (a) => a\n// Message: undefined\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\nasync(a) => a\n// Message: undefined\n```\n\nThe following patterns are not considered problems:\n\n```js\n() => {}\n\n(a) => {}\n\n(a) => a\n\n(a) => {\n}\n\na.then((foo) => {});\n\na.then((foo) => { if (true) {}; });\n\na.then(async (foo) => { if (true) {}; });\n\n// Options: [\"always\"]\n() => {}\n\n// Options: [\"always\"]\n(a) => {}\n\n// Options: [\"always\"]\n(a) => a\n\n// Options: [\"always\"]\n(a) => {\n}\n\n// Options: [\"always\"]\na.then((foo) => {});\n\n// Options: [\"always\"]\na.then((foo) => { if (true) {}; });\n\n// Options: [\"always\"]\na.then(async (foo) => { if (true) {}; });\n\n// Options: [\"as-needed\"]\n() => {}\n\n// Options: [\"as-needed\"]\na => {}\n\n// Options: [\"as-needed\"]\na => a\n\n// Options: [\"as-needed\"]\n([a, b]) => {}\n\n// Options: [\"as-needed\"]\n({ a, b }) => {}\n\n// Options: [\"as-needed\"]\n(a = 10) => {}\n\n// Options: [\"as-needed\"]\n(...a) => a[0]\n\n// Options: [\"as-needed\"]\n(a, b) => {}\n\n// Options: [\"as-needed\"]\nasync ([a, b]) => {}\n\n// Options: [\"as-needed\"]\nasync (a, b) => {}\n\n// Options: [\"as-needed\"]\n(a: T) => a\n\n// Options: [\"as-needed\"]\n(a): T => a\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n() => {}\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\na => a\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n([a, b]) => {}\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n([a, b]) => a\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n({ a, b }) => {}\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n({ a, b }) => a + b\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n(a = 10) => {}\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n(...a) => a[0]\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n(a, b) => {}\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\na => ({})\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\nasync a => ({})\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\nasync a => a\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n(a: T) => a\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n(a): T => a\n\n// Options: [\"always\",{\"requireForBlockBody\":true}]\n<T>(a: T) => a\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":false}]\n<T>(a: T) => { return a; }\n\n// Options: [\"always\",{\"requireForBlockBody\":true}]\n<T>(a: T) => { return a; }\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n<T>(a: T) => { return a; }\n\n// Options: [\"as-needed\",{\"requireForBlockBody\":true}]\n(a): %checks => typeof a === \"number\"\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-boolean-style\"></a>\n### <code>boolean-style</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces a particular style for boolean type annotations. This rule takes one argument.\n\nIf it is `'boolean'` then a problem is raised when using `bool` instead of `boolean`.\n\nIf it is `'bool'` then a problem is raised when using `boolean` instead of `bool`.\n\nThe default value is `'boolean'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = bool\n// Message: Use \"boolean\", not \"bool\"\n\n// Options: [\"boolean\"]\ntype X = bool\n// Message: Use \"boolean\", not \"bool\"\n\n// Options: [\"bool\"]\ntype X = boolean\n// Message: Use \"bool\", not \"boolean\"\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = boolean\n\n// Options: [\"boolean\"]\ntype X = boolean\n\n// Options: [\"bool\"]\ntype X = bool\n\n// Options: [\"boolean\"]\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype X = bool\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-define-flow-type\"></a>\n### <code>define-flow-type</code>\n\nMarks Flow type identifiers as defined.\n\nUsed to suppress [`no-undef`](http://eslint.org/docs/rules/no-undef) reporting of type identifiers.\n\nThe following patterns are not considered problems:\n\n```js\nvar a: AType\n// Additional rules: {\"no-undef\":2}\n\nvar a: AType; var b: AType\n// Additional rules: {\"no-undef\":2}\n\nvar a; (a: AType)\n// Additional rules: {\"no-undef\":2}\n\nvar a: AType<BType>\n// Additional rules: {\"no-undef\":2}\n\ntype A = AType\n// Additional rules: {\"no-undef\":2}\n\ndeclare type A = number\n// Additional rules: {\"no-undef\":2}\n\nopaque type A = AType\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a: AType) {}\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a: AType.a) {}\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a: AType.a.b) {}\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a): AType {}; var a: AType\n// Additional rules: {\"no-undef\":2}\n\nfunction f(a): AType {}\n// Additional rules: {\"no-undef\":2}\n\nclass C { a: AType }\n// Additional rules: {\"no-undef\":2}\n\nclass C { a: AType.a }\n// Additional rules: {\"no-undef\":2}\n\nclass C { a: AType.a.b }\n// Additional rules: {\"no-undef\":2}\n\nclass C implements AType {}\n// Additional rules: {\"no-undef\":2}\n\ndeclare interface A {}\n// Additional rules: {\"no-undef\":2}\n\n({ a: ({b() {}}: AType) })\n// Additional rules: {\"no-undef\":2}\n\ntype X = {Y<AType>(): BType}\n// Additional rules: {\"no-undef\":2}\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\n\n/**\n* Copyright 2019 no corp\n* @flow\n*/\ntype Foo = $ReadOnly<{}>\n// Additional rules: {\"no-undef\":2}\n\nvar a: AType\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nvar a: AType; var b: AType\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nvar a; (a: AType)\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nvar a: AType<BType>\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\ntype A = AType\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\ndeclare type A = number\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nopaque type A = AType\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a: AType) {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a: AType.a) {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a: AType.a.b) {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a): AType {}; var a: AType\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nfunction f(a): AType {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nclass C { a: AType }\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nclass C { a: AType.a }\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nclass C { a: AType.a.b }\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\nclass C implements AType {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\ndeclare interface A {}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\n({ a: ({b() {}}: AType) })\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\ntype X = {Y<AType>(): BType}\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\n\n/**\n* Copyright 2019 no corp\n* @flow\n*/\ntype Foo = $ReadOnly<{}>\n// Additional rules: {\"no-undef\":2,\"no-use-before-define\":[2,\"nofunc\"]}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-delimiter-dangle\"></a>\n### <code>delimiter-dangle</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent use of trailing commas in Object and Tuple annotations.\n\nThis rule takes three arguments where the possible values are the same as ESLint's default `comma-dangle` rule:\n\n1. The first argument is for Object and Tuple annotations. The default value is `'never'`.\n2. The second argument is used for Interface annotations. This defaults to the value of the first argument.\n3. The third argument is used for inexact object notation (trailing `...`). The default value is `'never'`.\n\nIf it is `'never'` then a problem is raised when there is a trailing comma.\n\nIf it is `'always'` then a problem is raised when there is no trailing comma.\n\nIf it is `'always-multiline'` then a problem is raised when there is no trailing comma on a multi-line definition, or there _is_ a trailing comma on a single-line definition.\n\nIf it is `'only-multiline'` then a problem is raised when there is a trailing comma on a single-line definition. It allows, but does not enforce, trailing commas on multi-line definitions.\n\nThe following patterns are considered problems:\n\n```js\ntype X = { foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { foo: string; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\nfoo: string,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = { foo: string }\n// Message: Missing trailing delimiter\n\n// Options: [\"always\"]\ntype X = {\nfoo: string\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = { foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = { foo: string; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\",\"never\"]\ninterface X { foo: string; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { [key: string]: number, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = { [key: string]: number }\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = { [key: string]: number, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = {\n[key: string]: number\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = { [key: string]: number; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { [key: string]: number, foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\n[key: string]: number,\nfoo: string,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\n[key: string]: number,\naReallyLongPropertyNameHere: string,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = { [key: string]: number, foo: string }\n// Message: Missing trailing delimiter\n\n// Options: [\"always\"]\ntype X = {\n[key: string]: number;\nfoo: string\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = { [key: string]: number, foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = {\n[key: string]: number,\nfoo: string\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = { [key: string]: number, foo: string, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = { foo: string, [key: string]: number, }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\nfoo: string,\n[key: string]: number,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = {\naReallyLongPropertyNameHere: string,\n[key: string]: number,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = { foo: string, [key: string]: number }\n// Message: Missing trailing delimiter\n\n// Options: [\"always\"]\ntype X = { foo: string; [key: string]: number }\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = { foo: string, [key: string]: number; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string,\n[key: string]: number\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = { foo: string, [key: string]: number; }\n// Message: Unexpected trailing delimiter\n\ntype X = { ..., }\n// Message: Unexpected trailing delimiter\n\ntype X = { ...; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = { ..., }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = { ...; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = { ... }\n// Message: Missing trailing delimiter\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = { ..., }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = { ...; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = { ..., }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = { ...; }\n// Message: Unexpected trailing delimiter\n\ntype X = {\n...,\n}\n// Message: Unexpected trailing delimiter\n\ntype X = {\n...;\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = {\n...,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = {\n...;\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = {\n...\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = {\n...\n}\n// Message: Missing trailing delimiter\n\ntype X = { foo: string, ..., }\n// Message: Unexpected trailing delimiter\n\ntype X = { foo: string; ...; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = { foo: string, ..., }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = { foo: string; ...; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = { foo: string, ... }\n// Message: Missing trailing delimiter\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = { foo: string, ..., }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = { foo: string; ...; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = { foo: string, ..., }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = { foo: string; ...; }\n// Message: Unexpected trailing delimiter\n\ntype X = {\nfoo: string,\n...,\n}\n// Message: Unexpected trailing delimiter\n\ntype X = {\nfoo: string;\n...;\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = {\nfoo: string,\n...,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = {\nfoo: string;\n...;\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = {\nfoo: string,\n...\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = {\nfoo: string,\n...\n}\n// Message: Missing trailing delimiter\n\ntype X = { [key: string]: number, ..., }\n// Message: Unexpected trailing delimiter\n\ntype X = { [key: string]: number; ...; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = { [key: string]: number, ..., }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = { [key: string]: number; ...; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = { [key: string]: number, ... }\n// Message: Missing trailing delimiter\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = { [key: string]: number, ..., }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = { [key: string]: number; ...; }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = { [key: string]: number, ..., }\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = { [key: string]: number; ...; }\n// Message: Unexpected trailing delimiter\n\ntype X = {\n[key: string]: number,\n...,\n}\n// Message: Unexpected trailing delimiter\n\ntype X = {\n[key: string]: number;\n...;\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = {\n[key: string]: number,\n...,\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = {\n[key: string]: number;\n...;\n}\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = {\n[key: string]: number,\n...\n}\n// Message: Missing trailing delimiter\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = {\n[key: string]: number,\n...\n}\n// Message: Missing trailing delimiter\n\ntype X = [string, number,]\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = [string, number,]\n// Message: Unexpected trailing delimiter\n\n// Options: [\"never\"]\ntype X = [\nstring,\nnumber,\n]\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always\"]\ntype X = [string, number]\n// Message: Missing trailing delimiter\n\n// Options: [\"always\"]\ntype X = [\nstring,\nnumber\n]\n// Message: Missing trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = [string, number,]\n// Message: Unexpected trailing delimiter\n\n// Options: [\"always-multiline\"]\ntype X = [\nfoo, string\n]\n// Message: Missing trailing delimiter\n\n// Options: [\"only-multiline\"]\ntype X = [ number, string, ]\n// Message: Unexpected trailing delimiter\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = { foo: string }\n\n// Options: [\"never\"]\ntype X = { foo: string }\n\n// Options: [\"always\"]\ntype X = { foo: string, }\n\n// Options: [\"always\"]\ntype X = { foo: string; }\n\n// Options: [\"never\"]\ntype X = {\nfoo: string\n}\n\n// Options: [\"always\"]\ntype X = {\nfoo: string,\n}\n\n// Options: [\"always-multiline\"]\ntype X = { foo: string }\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string,\n}\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string;\n}\n\n// Options: [\"only-multiline\"]\ntype X = { foo: string }\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string;\n}\n\n// Options: [\"never\",\"always\"]\ninterface X { foo: string; }\n\n// Options: [\"never\"]\ntype X = {}\n\n// Options: [\"always\"]\ntype X = {}\n\n// Options: [\"always-multiline\"]\ntype X = {}\n\n// Options: [\"only-multiline\"]\ntype X = {}\n\n// Options: [\"never\"]\ntype X = { [key: string]: number }\n\n// Options: [\"always\"]\ntype X = { [key: string]: number, }\n\n// Options: [\"always\"]\ntype X = { [key: string]: number; }\n\n// Options: [\"always-multiline\"]\ntype X = { [key: string]: number }\n\n// Options: [\"always-multiline\"]\ntype X = {\n[key: string]: number,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\n[key: string]: number,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\n[key: string]: number\n}\n\n// Options: [\"only-multiline\"]\ntype X = { [key: string]: number }\n\n// Options: [\"never\"]\ntype X = { [key: string]: number, foo: string }\n\n// Options: [\"always\"]\ntype X = { [key: string]: number, foo: string, }\n\n// Options: [\"always\"]\ntype X = { [key: string]: number; foo: string; }\n\n// Options: [\"always-multiline\"]\ntype X = { [key: string]: number, foo: string }\n\n// Options: [\"always-multiline\"]\ntype X = {\n[key: string]: number,\nfoo: string,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\n[key: string]: number,\nfoo: string,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\n[key: string]: number;\nfoo: string\n}\n\n// Options: [\"only-multiline\"]\ntype X = { [key: string]: number, foo: string }\n\n// Options: [\"never\"]\ntype X = { foo: string, [key: string]: number }\n\n// Options: [\"always\"]\ntype X = { foo: string, [key: string]: number, }\n\n// Options: [\"always\"]\ntype X = { foo: string; [key: string]: number; }\n\n// Options: [\"always-multiline\"]\ntype X = { foo: string, [key: string]: number }\n\n// Options: [\"always-multiline\"]\ntype X = {\nfoo: string,\n[key: string]: number,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string,\n[key: string]: number,\n}\n\n// Options: [\"only-multiline\"]\ntype X = {\nfoo: string;\n[key: string]: number\n}\n\n// Options: [\"only-multiline\"]\ntype X = { foo: string, [key: string]: number }\n\ntype X = { ... }\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = { ... }\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = { ..., }\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = { ... }\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = { ... }\n\ntype X = {\n...\n}\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = {\n...\n}\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = {\n...,\n }\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = {\n...;\n }\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = {\n...,\n}\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = {\n...;\n}\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = {\n...\n}\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = {\n...,\n}\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = {\n...;\n}\n\ntype X = { foo: string, ... }\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = { foo: string, ... }\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = { foo: string, ..., }\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = { foo: string; ...; }\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = { foo: string, ... }\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = { foo: string, ... }\n\ntype X = {\nfoo: string,\n...\n}\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = {\nfoo: string,\n...\n}\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = {\nfoo: string,\n...,\n}\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = {\nfoo: string;\n...;\n}\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = {\nfoo: string,\n...,\n}\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = {\nfoo: string;\n...;\n}\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = {\nfoo: string,\n...\n}\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = {\nfoo: string,\n...,\n}\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = {\nfoo: string,\n...;\n}\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = { [key: string]: number, ... }\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = { [key: string]: number, ..., }\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = { [key: string]: number; ...; }\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = { [key: string]: number, ... }\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = { [key: string]: number, ... }\n\n// Options: [\"never\",\"never\",\"never\"]\ntype X = {\n[key: string]: number,\n...\n}\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = {\n[key: string]: number,\n...,\n}\n\n// Options: [\"never\",\"never\",\"always\"]\ntype X = {\n[key: string]: number;\n...;\n}\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = {\n[key: string]: number,\n...,\n}\n\n// Options: [\"never\",\"never\",\"always-multiline\"]\ntype X = {\n[key: string]: number;\n...;\n}\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = {\n[key: string]: number,\n...\n}\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = {\n[key: string]: number,\n...,\n}\n\n// Options: [\"never\",\"never\",\"only-multiline\"]\ntype X = {\n[key: string]: number;\n...;\n}\n\ntype X = [string, number]\n\n// Options: [\"never\"]\ntype X = [string, number]\n\n// Options: [\"never\"]\ntype X = [\nstring,\nnumber\n]\n\n// Options: [\"always\"]\ntype X = [string, number,]\n\n// Options: [\"always\"]\ntype X = [\nstring,\nnumber,\n]\n\n// Options: [\"always-multiline\"]\ntype X = [ foo, string ]\n\n// Options: [\"always-multiline\"]\ntype X = [\nfoo, string,\n]\n\n// Options: [\"only-multiline\"]\ntype X = [ number, string ]\n\n// Options: [\"only-multiline\"]\ntype X = [\nnumber,\nstring\n]\n\n// Options: [\"only-multiline\"]\ntype X = [\nnumber,\nstring,\n]\n\n// Options: [\"never\"]\ntype X = []\n\n// Options: [\"always\"]\ntype X = []\n\n// Options: [\"always-multiline\"]\ntype X = []\n\n// Options: [\"only-multiline\"]\ntype X = []\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-enforce-line-break\"></a>\n### <code>enforce-line-break</code>\n\nThis rule enforces line breaks between type definitions.\n\nThe following patterns are considered problems:\n\n```js\ntype baz = 6;\nconst hi = 2;\n// Message: New line required below type declaration\n\nconst foo = 6;\ntype hi = 2;\n\n// Message: New line required above type declaration\n\nconst som = \"jes\";\n// a comment\ntype fed = \"hed\";\n\n// Message: New line required above type declaration\n\ntype som = \"jes\";\n// a comment\nconst fed = \"hed\";\n\n// Message: New line required below type declaration\n\ntype hello = 34;\nconst som = \"jes\";\ntype fed = \"hed\";\n\n// Message: New line required below type declaration\n// Message: New line required above type declaration\n\nconst a = 5;\nexport type hello = 34;\n\n// Message: New line required above type declaration\n\nconst a = 5;\n// a comment\nexport type hello = 34;\n\n// Message: New line required above type declaration\n\nconst a = 5;\n/**\n * a jsdoc block\n */\ntype hello = 34;\n// Message: New line required above type declaration\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype gjs = 6;\n\ntype gjs = 6;\n\ntype hi = 2;\n\n\ntype X = 4;\n\nconst red = \"serpent\";\nconsole.log(\"hello\");\n\n// number or string\ntype Y = string | number;\n\n// resting + sleep\ntype snooze = \"dreaming\" | \"\";\n\ntype Props = {\n  accountBalance: string | number,\n  accountNumber: string | number,\n};\n\nconst x = 4;\nconst y = 489;\n\n// Some Comment\ntype Props = {\n  accountBalance: string | number,\n  accountNumber: string | number,\n};\n\ntype RoadT = \"grass\" | \"gravel\" | \"cement\";\n\n// @flow\ntype A = string\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-generic-spacing\"></a>\n### <code>generic-spacing</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing within generic type annotation parameters.\n\nThis rule takes one argument. If it is `'never'` then a problem is raised when there is a space surrounding the generic type parameters. If it is `'always'` then a problem is raised when there is no space surrounding the generic type parameters.\n\nThe default value is `'never'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = Promise< string>\n// Message: There must be no space at start of \"Promise\" generic type annotation\n\n// Options: [\"never\"]\ntype X = Promise<  string>\n// Message: There must be no space at start of \"Promise\" generic type annotation\n\ntype X = FooBar<string >\n// Message: There must be no space at end of \"FooBar\" generic type annotation\n\ntype X = Promise< string >\n// Message: There must be no space at start of \"Promise\" generic type annotation\n// Message: There must be no space at end of \"Promise\" generic type annotation\n\ntype X = Promise< (foo), bar, (((baz))) >\n// Message: There must be no space at start of \"Promise\" generic type annotation\n// Message: There must be no space at end of \"Promise\" generic type annotation\n\n// Options: [\"always\"]\ntype X = Promise<string >\n// Message: There must be a space at start of \"Promise\" generic type annotation\n\n// Options: [\"always\"]\ntype X = FooBar< string>\n// Message: There must be a space at end of \"FooBar\" generic type annotation\n\n// Options: [\"always\"]\ntype X = Promise<string>\n// Message: There must be a space at start of \"Promise\" generic type annotation\n// Message: There must be a space at end of \"Promise\" generic type annotation\n\n// Options: [\"always\"]\ntype X = Promise<(foo), bar, (((baz)))>\n// Message: There must be a space at start of \"Promise\" generic type annotation\n// Message: There must be a space at end of \"Promise\" generic type annotation\n\n// Options: [\"always\"]\ntype X = FooBar<  string >\n// Message: There must be one space at start of \"FooBar\" generic type annotation\n\n// Options: [\"always\"]\ntype X = FooBar< string  >\n// Message: There must be one space at end of \"FooBar\" generic type annotation\n\n// Options: [\"always\"]\ntype X = Promise<  (foo), bar, (((baz)))  >\n// Message: There must be one space at start of \"Promise\" generic type annotation\n// Message: There must be one space at end of \"Promise\" generic type annotation\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = Promise<string>\n\ntype X = Promise<(string)>\n\ntype X = Promise<(foo), bar, (((baz)))>\n\ntype X = Promise<\n  (foo),\n  bar,\n  (((baz)))\n>\n\ntype X =  Promise<\n    (foo),\n    bar,\n    (((baz)))\n>\n\n// Options: [\"always\"]\ntype X = Promise< string >\n\n// Options: [\"always\"]\ntype X = Promise< (string) >\n\n// Options: [\"always\"]\ntype X = Promise< (foo), bar, (((baz))) >\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-interface-id-match\"></a>\n### <code>interface-id-match</code>\n\nEnforces a consistent naming pattern for interfaces.\n\n<a name=\"eslint-plugin-flowtype-rules-interface-id-match-options\"></a>\n#### Options\n\nThis rule requires a text RegExp:\n\n```js\n{\n    \"rules\": {\n        \"flowtype/interface-id-match\": [\n            2,\n            \"^([A-Z][a-z0-9]*)+Type$\"\n        ]\n    }\n}\n```\n\n`'^([A-Z][a-z0-9]*)+Type$$'` is the default pattern.\n\nThe following patterns are considered problems:\n\n```js\ninterface foo{};\n// Message: Interface identifier 'foo' does not match pattern '/^([A-Z][a-z0-9]*)+Type$/u'.\n\n// Options: [\"^foo$\"]\ninterface FooType{};\n// Message: Interface identifier 'FooType' does not match pattern '/^foo$/u'.\n```\n\nThe following patterns are not considered problems:\n\n```js\ninterface FooType {};\n\n// Options: [\"^foo$\"]\ninterface foo {};\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ninterface foo {};\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-newline-after-flow-annotation\"></a>\n### <code>newline-after-flow-annotation</code>\n\nThis rule requires an empty line after the Flow annotation.\n\n<a name=\"eslint-plugin-flowtype-rules-newline-after-flow-annotation-options-1\"></a>\n#### Options\n\nThe rule has a string option:\n\n* `\"always\"` (default): Enforces that `@flow` annotations be followed by an empty line, separated by newline (LF)\n* `\"always-windows\"`: Identical to \"always\", but will use a CRLF when autofixing\n* `\"never\"`: Enforces that `@flow` annotations are not followed by empty lines\n\n```js\n{\n  \"rules\": {\n    \"flowtype/newline-after-flow-annotation\": [\n      2,\n      \"always\"\n    ]\n  }\n}\n```\n\n\nThe following patterns are considered problems:\n\n```js\n// @flow\nimport Foo from './foo';\n// Message: Expected newline after flow annotation\n\n// Options: [\"always\"]\n// @flow\nimport Foo from './foo';\n// Message: Expected newline after flow annotation\n\n// Options: [\"always-windows\"]\n// @flow\nimport Foo from './foo';\n// Message: Expected newline after flow annotation\n\n// Options: [\"never\"]\n// @flow\n\n\n// Message: Expected no newline after flow annotation\n```\n\nThe following patterns are not considered problems:\n\n```js\n// Options: [\"always\"]\n// @flow\n\nimport Foo from './foo';\n\n// Options: [\"always-windows\"]\n// @flow\n\nimport Foo from './foo';\n\n// Options: [\"never\"]\n// @flow\nimport Foo from './foo';\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-dupe-keys\"></a>\n### <code>no-dupe-keys</code>\n\nChecks for duplicate properties in Object annotations.\n\nThis rule mirrors ESLint's [no-dupe-keys](http://eslint.org/docs/rules/no-dupe-keys) rule.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/no-dupe-keys\": 2\n    }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype f = { a: number, b: string, a: number }\n// Message: Duplicate property.\n\ntype f = { a: number, b: string, a: string }\n// Message: Duplicate property.\n\ntype f = { get(key: \"a\"): string, get(key: \"a\"): string }\n// Message: Duplicate property.\n\ntype f = { get(key: 1): string, get(key: 1): string }\n// Message: Duplicate property.\n\ntype f = { get(key: 1.1): string, get(key: 1.1): string }\n// Message: Duplicate property.\n\ntype f = { get(key: true): string, get(key: true): string }\n// Message: Duplicate property.\n\ntype f = { get(key: {a: 1}): string, get(key: {a: 1}):string }\n// Message: Duplicate property.\n\nvar a = \"a\"; type f = { get(key: a): string, get(key: a): string }\n// Message: Duplicate property.\n\nvar b = 1; type f = { get(key: b): string, get(key: b): string }\n// Message: Duplicate property.\n\nvar c = true; type f = { get(key: c): string, get(key: c): string }\n// Message: Duplicate property.\n\nvar d = {}; type f = { get(key: d): string, get(key: d): string }\n// Message: Duplicate property.\n\nvar e = []; type f = { get(key: e): string, get(key: e): string }\n// Message: Duplicate property.\n\nvar e = [1, \"a\"]; type f = { get(key: e): string, get(key: e): string }\n// Message: Duplicate property.\n\nfunction fn() {}; type f = { get(key: fn): string, get(key: fn): string }\n// Message: Duplicate property.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype FooType = { a: number, b: string, c: number }\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype FooType = { a: number, b: string, a: number }\n\ntype f = { get(key: \"a\"): string, get(key: \"b\"): string }\n\ntype f = { get(key: 1): string, get(key: 2): string }\n\ntype f = { get(key: 1.1): string, get(key: 1.2): string }\n\ntype f = { get(key: true): string, get(key: false): string }\n\ntype f = { get(key: [\"a\", 1]): string, get(key: [\"a\", 2]): string }\n\ntype f = { get(key: [\"a\", [\"b\", 1]]): string, get(key: [\"a\", [\"b\", 2]]): string }\n\ntype f = { a: number, b: string, c: number }\n\ntype f = { get(key: \"a\"): string, get(key: \"b\"): string }\n\ntype f = { get(key: \"a\"): string, get(key: \"a\", key2: \"b\"): string }\n\ntype f = { get(key: \"a\"): string, get(key: 1): string }\n\ntype f = { get(key: { a: 1 }): string, get(key: { a: 2 }): string}\n\nvar a = {}; var b = {}; type f = { get(key: a): string, get(key: b): string }\n\nvar a = 1; var b = 1; type f = { get(key: a): string, get(key: b): string }\n\ntype a = { b: <C>(config: { ...C, key: string}) => C }\n\nexport interface Foo { get foo(): boolean; get bar(): string; }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-duplicate-type-union-intersection-members\"></a>\n### <code>no-duplicate-type-union-intersection-members</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nChecks for duplicate members of a type union/intersection.\n\n<a name=\"eslint-plugin-flowtype-rules-no-duplicate-type-union-intersection-members-options-2\"></a>\n#### Options\n\nYou can disable checking intersection types using `checkIntersections`.\n\n* `true` (default) - check for duplicate members of intersection members.\n* `false` - do not check for duplicate members of intersection members.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/no-duplicate-type-union-intersection-members\": [\n      2,\n      {\n        \"checkIntersections\": true\n      }\n    ]\n  }\n}\n```\n\nYou can disable checking union types using `checkUnions`.\n\n* `true` (default) - check for duplicate members of union members.\n* `false` - do not check for duplicate members of union members.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/no-duplicate-type-union-intersection-members\": [\n      2,\n      {\n        \"checkUnions\": true\n      }\n    ]\n  }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype A = 1 | 2 | 3 | 1;\n// Message: Duplicate union member found \"1\".\n\ntype B = 'foo' | 'bar' | 'foo';\n// Message: Duplicate union member found \"'foo'\".\n\ntype C = A | B | A | B;\n// Message: Duplicate union member found \"A\".\n// Message: Duplicate union member found \"B\".\n\ntype C = A & B & A & B;\n// Message: Duplicate intersection member found \"A\".\n// Message: Duplicate intersection member found \"B\".\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype A = 1 | 2 | 3;\n\ntype B = 'foo' | 'bar';\n\ntype C = A | B;\n\ntype C = A & B;\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-existential-type\"></a>\n### <code>no-existential-type</code>\n\nDisallows use of the existential type (*). [See more](https://flow.org/en/docs/types/utilities/#toc-existential-type)\n\n```js\n{\n  \"rules\": {\n    \"flowtype/no-existential-type\": 2\n  }\n}\n```\n\n\nThe following patterns are considered problems:\n\n```js\ntype T = *;\n// Message: Unexpected use of existential type (*).\n\ntype T = U<*, *>;\n// Message: Unexpected use of existential type (*).\n// Message: Unexpected use of existential type (*).\n\nconst f: (*) => null = () => null;\n// Message: Unexpected use of existential type (*).\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype T = string | null\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-flow-fix-me-comments\"></a>\n### <code>no-flow-fix-me-comments</code>\n\nDisallows `$FlowFixMe` comment suppressions.\n\nThis is especially useful as a warning to ensure instances of `$FlowFixMe` in your codebase get fixed over time.\n\n<a name=\"eslint-plugin-flowtype-rules-no-flow-fix-me-comments-options-3\"></a>\n#### Options\n\nThis rule takes an optional RegExp that comments a text RegExp that makes the supression valid.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/no-flow-fix-me-comments\": [\n            1,\n            \"TODO\\s+[0-9]+\"\n        ]\n    }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\n// $FlowFixMe I am doing something evil here\nconst text = 'HELLO';\n// Message: $FlowFixMe is treated as `any` and must be fixed.\n\n// Options: [\"TODO [0-9]+\"]\n// $FlowFixMe I am doing something evil here\nconst text = 'HELLO';\n// Message: $FlowFixMe is treated as `any` and must be fixed. Fix it or match `/TODO [0-9]+/u`.\n\n// Options: [\"TODO [0-9]+\"]\n// $FlowFixMe TODO abc 47 I am doing something evil here\nconst text = 'HELLO';\n// Message: $FlowFixMe is treated as `any` and must be fixed. Fix it or match `/TODO [0-9]+/u`.\n\n// $$FlowFixMeProps I am doing something evil here\nconst text = 'HELLO';\n// Message: $FlowFixMe is treated as `any` and must be fixed.\n\n// Options: [\"TODO [0-9]+\"]\n// $FlowFixMeProps I am doing something evil here\nconst text = 'HELLO';\n// Message: $FlowFixMe is treated as `any` and must be fixed. Fix it or match `/TODO [0-9]+/u`.\n```\n\nThe following patterns are not considered problems:\n\n```js\nconst text = 'HELLO';\n\n// Options: [\"TODO [0-9]+\"]\n// $FlowFixMe TODO 48\nconst text = 'HELLO';\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-internal-flow-type\"></a>\n### <code>no-internal-flow-type</code>\n\nWarns against using internal Flow types such as `React$Node`, `React$Ref` and others and suggests using public alternatives instead (`React.Node`, `React.Ref`, ).\n\nThe following patterns are considered problems:\n\n```js\ntype X = React$AbstractComponent<Config, Instance>\n// Message: Type identifier 'React$AbstractComponent' is not allowed. Use 'React.AbstractComponent' instead.\n\ntype X = React$ChildrenArray<string>\n// Message: Type identifier 'React$ChildrenArray' is not allowed. Use 'React.ChildrenArray' instead.\n\ntype X = React$ComponentType<Props>\n// Message: Type identifier 'React$ComponentType' is not allowed. Use 'React.ComponentType' instead.\n\ntype X = React$Config<Prosp, DefaultProps>\n// Message: Type identifier 'React$Config' is not allowed. Use 'React.Config' instead.\n\ntype X = React$Element<typeof Component>\n// Message: Type identifier 'React$Element' is not allowed. Use 'React.Element' instead.\n\ntype X = React$ElementConfig<typeof Component>\n// Message: Type identifier 'React$ElementConfig' is not allowed. Use 'React.ElementConfig' instead.\n\ntype X = React$ElementProps<typeof Component>\n// Message: Type identifier 'React$ElementProps' is not allowed. Use 'React.ElementProps' instead.\n\ntype X = React$ElementRef<typeof Component>\n// Message: Type identifier 'React$ElementRef' is not allowed. Use 'React.ElementRef' instead.\n\ntype X = React$ElementType\n// Message: Type identifier 'React$ElementType' is not allowed. Use 'React.ElementType' instead.\n\ntype X = React$Key\n// Message: Type identifier 'React$Key' is not allowed. Use 'React.Key' instead.\n\ntype X = React$Node\n// Message: Type identifier 'React$Node' is not allowed. Use 'React.Node' instead.\n\ntype X = React$Ref<typeof Component>\n// Message: Type identifier 'React$Ref' is not allowed. Use 'React.Ref' instead.\n\ntype X = React$StatelessFunctionalComponent<Props>\n// Message: Type identifier 'React$StatelessFunctionalComponent' is not allowed. Use 'React.StatelessFunctionalComponent' instead.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = React.AbstractComponent<Config, Instance>\n\ntype X = React.ChildrenArray<string>\n\ntype X = React.ComponentType<Props>\n\ntype X = React.Config<Props, DefaultProps>\n\ntype X = React.Element<typeof Component>\n\ntype X = React.ElementConfig<typeof Component>\n\ntype X = React.ElementProps<typeof Component>\n\ntype X = React.ElementRef<typeof Component>\n\ntype X = React.ElementType\n\ntype X = React.Key\n\ntype X = React.Node\n\ntype X = React.Ref<typeof Component>\n\ntype X = React.StatelessFunctionalComponent<Props>\n\ntype X = React$Rocks\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-mixed\"></a>\n### <code>no-mixed</code>\n\nWarns against \"mixed\" type annotations.\nThese types are not strict enough and could often be made more specific.\n\nThe following patterns are considered problems:\n\nThe following patterns are considered problems:\n\n```js\nfunction foo(thing): mixed {}\n// Message: Unexpected use of mixed type\n\nfunction foo(thing): Promise<mixed> {}\n// Message: Unexpected use of mixed type\n\nfunction foo(thing): Promise<Promise<mixed>> {}\n// Message: Unexpected use of mixed type\n```\n\nThe following patterns are not considered problems:\n\n```js\nfunction foo(thing): string {}\n\nfunction foo(thing): Promise<string> {}\n\nfunction foo(thing): Promise<Promise<string>> {}\n\n(foo?: string) => {}\n\n(foo: ?string) => {}\n\n(foo: { a: string }) => {}\n\n(foo: { a: ?string }) => {}\n\n(foo: string[]) => {}\n\ntype Foo = string\n\ntype Foo = { a: string }\n\ntype Foo = { (a: string): string }\n\nfunction foo(thing: string) {}\n\nvar foo: string\n\nclass Foo { props: string }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-mutable-array\"></a>\n### <code>no-mutable-array</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nRequires use of [`$ReadOnlyArray`](https://github.com/facebook/flow/blob/v0.46.0/lib/core.js#L185) instead of just `Array` or array [shorthand notation](https://flow.org/en/docs/types/arrays/#toc-array-type-shorthand-syntax). `$ReadOnlyArray` is immutable array collection type and the superclass of Array and tuple types in Flow. Use of `$ReadOnlyArray` instead of `Array` can solve some \"problems\" in typing with Flow (e.g., [1](https://github.com/facebook/flow/issues/3425), [2](https://github.com/facebook/flow/issues/4251)).\n\nGeneral reasons for using immutable data structures:\n\n* They are simpler to construct, test, and use\n* They help to avoid temporal coupling\n* Their usage is side-effect free (no defensive copies)\n* Identity mutability problem is avoided\n* They always have failure atomicity\n* They are much easier to cache\n\nNote that initialization of a variable with an empty array is considered valid (e.g., `const values: Array<string> = [];`). This behavior resembles the behavior of Flow's [unsealed objects](https://flow.org/en/docs/types/objects/#toc-unsealed-objects), as it is assumed that empty array is intended to be mutated.\n\nThe following patterns are considered problems:\n\n```js\ntype X = Array<string>\n// Message: Use \"$ReadOnlyArray\" instead of \"Array\"\n\ntype X = string[]\n// Message: Use \"$ReadOnlyArray\" instead of array shorthand notation\n\nconst values: Array<Array<string>> = [];\n// Message: Use \"$ReadOnlyArray\" instead of \"Array\"\n\nlet values: Array<Array<string>>;\n// Message: Use \"$ReadOnlyArray\" instead of \"Array\"\n// Message: Use \"$ReadOnlyArray\" instead of \"Array\"\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = $ReadOnlyArray<string>\n\nconst values: Array<$ReadOnlyArray<string>> = [];\n\nconst values: $ReadOnlyArray<string>[] = [];\n\nconst values: Array<$ReadOnlyArray<string>> = new Array();\n\nconst values: Array<$ReadOnlyArray<string>> = Array();\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-primitive-constructor-types\"></a>\n### <code>no-primitive-constructor-types</code>\n\nDisallows use of primitive constructors as types, such as `Boolean`, `Number` and `String`. [See more](https://flowtype.org/docs/builtins.html).\n\n```js\n{\n    \"rules\": {\n        \"flowtype/no-primitive-constructor-types\": 2\n    }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype x = Number\n// Message: Unexpected use of Number constructor type.\n\ntype x = String\n// Message: Unexpected use of String constructor type.\n\ntype x = Boolean\n// Message: Unexpected use of Boolean constructor type.\n\ntype x = { a: Number }\n// Message: Unexpected use of Number constructor type.\n\ntype x = { a: String }\n// Message: Unexpected use of String constructor type.\n\ntype x = { a: Boolean }\n// Message: Unexpected use of Boolean constructor type.\n\n(x: Number) => {}\n// Message: Unexpected use of Number constructor type.\n\n(x: String) => {}\n// Message: Unexpected use of String constructor type.\n\n(x: Boolean) => {}\n// Message: Unexpected use of Boolean constructor type.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype x = number\n\ntype x = string\n\ntype x = boolean\n\ntype x = { a: number }\n\ntype x = { a: string }\n\ntype x = { a: boolean }\n\n(x: number) => {}\n\n(x: string) => {}\n\n(x: boolean) => {}\n\ntype x = MyNumber\n\ntype x = MyString\n\ntype x = MyBoolean\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-types-missing-file-annotation\"></a>\n### <code>no-types-missing-file-annotation</code>\n\nDisallows Flow type imports, aliases, and annotations in files missing a valid Flow file declaration (or a @noflow annotation).\n\n```js\n{\n    \"rules\": {\n        \"flowtype/no-types-missing-file-annotation\": 2\n    }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\nconst x: number = 42;\n// Message: Type annotations require valid Flow declaration.\n\ntype FooType = number;\n// Message: Type aliases require valid Flow declaration.\n\nimport type A from \"a\"\n// Message: Type imports require valid Flow declaration.\n\nimport type {A} from \"a\"\n// Message: Type imports require valid Flow declaration.\n\nimport {type A} from \"a\"\n// Message: Type imports require valid Flow declaration.\n\nexport type {A} from \"a\"\n// Message: Type exports require valid Flow declaration.\n\nfunction t<T>(): T{}\n// Message: Type annotations require valid Flow declaration.\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\nconst x: number = 42;\n// Message: Type annotations require valid Flow declaration.\n```\n\nThe following patterns are not considered problems:\n\n```js\n// @flow\nconst x: number = 42;\n\n/* @flow weak */\ntype FooType = number;\n\n/* @noflow */\ntype FooType = number;\n\n/* @noflow */\nimport type A from \"a\"\n\n/* @noflow */\nimport {type A} from \"a\"\n\n/* @noflow */\nexport type {A} from \"a\"\n\n// an unrelated comment\n// @flow\nexport type {A} from \"a\"\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-unused-expressions\"></a>\n### <code>no-unused-expressions</code>\n\nAn extension of [ESLint's `no-unused-expressions`](https://eslint.org/docs/rules/no-unused-expressions).\nThis rule ignores type cast expressions and optional call expressions, but otherwise behaves the same as ESLint's\n`no-unused-expressions`.\n\nBare type casts are useful, for example to assert the exhaustiveness of a `switch`:\n\n```js\ntype Action\n  = { type: 'FOO', doFoo: (_: number) => void }\n  | { type: 'BAR', doBar: (_: string) => void };\n\ntype State = { foo: number, bar: string };\n\nfunction runFooBar(action: Action, state: State): void {\n  switch (action.type) {\n    case 'FOO':\n      doFoo(state.foo);\n      break;\n    case 'BAR':\n      doBar(state.bar);\n      break;\n    default:\n      (action: empty);  // type error when `Action` is extended with new types\n      console.error(`Impossible action: ${action.toString()}`);\n  }\n}\n```\n\nThis rule takes the same arguments as ESLint's `no-unused-expressions`. See\n[that rule's documentation](https://eslint.org/docs/rules/no-unused-expressions) for details.\n\nThe following patterns are considered problems:\n\n```js\nfoo + 1\n// Message: Expected an assignment or function call and instead saw an expression.\n\nx?.y\n// Message: Expected an assignment or function call and instead saw an expression.\n```\n\nThe following patterns are not considered problems:\n\n```js\n(foo: number)\n\nx?.y()\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-no-weak-types\"></a>\n### <code>no-weak-types</code>\n\nWarns against weak type annotations *any*, *Object* and *Function*.\nThese types can cause flow to silently skip over portions of your code,\nwhich would have otherwise caused type errors.\n\nThis rule optionally takes one argument, an object to configure which type warnings to enable. By default, all of the\nwarnings are enabled. e.g. to disable the `any` warning (allowing it to exist in your code), while continuing to warn\nabout `Object` and `Function`:\n\n```js\n{\n    \"rules\": {\n        \"flowtype/no-weak-types\": [2, {\n            \"any\": false,\n            \"Object\": true,\n            \"Function\": true\n        }]\n    }\n}\n\n// or, the following is equivalent as default is true:\n\n{\n    \"rules\": {\n        \"flowtype/no-weak-types\": [2, {\n            \"any\": false\n        }]\n    }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\nfunction foo(thing): any {}\n// Message: Unexpected use of weak type \"any\"\n\nfunction foo(thing): Promise<any> {}\n// Message: Unexpected use of weak type \"any\"\n\nfunction foo(thing): Promise<Promise<any>> {}\n// Message: Unexpected use of weak type \"any\"\n\nfunction foo(thing): Object {}\n// Message: Unexpected use of weak type \"Object\"\n\nfunction foo(thing): Promise<Object> {}\n// Message: Unexpected use of weak type \"Object\"\n\nfunction foo(thing): Promise<Promise<Object>> {}\n// Message: Unexpected use of weak type \"Object\"\n\nfunction foo(thing): Function {}\n// Message: Unexpected use of weak type \"Function\"\n\nfunction foo(thing): Promise<Function> {}\n// Message: Unexpected use of weak type \"Function\"\n\nfunction foo(thing): Promise<Promise<Function>> {}\n// Message: Unexpected use of weak type \"Function\"\n\n(foo: any) => {}\n// Message: Unexpected use of weak type \"any\"\n\n(foo: Function) => {}\n// Message: Unexpected use of weak type \"Function\"\n\n(foo?: any) => {}\n// Message: Unexpected use of weak type \"any\"\n\n(foo?: Function) => {}\n// Message: Unexpected use of weak type \"Function\"\n\n(foo: { a: any }) => {}\n// Message: Unexpected use of weak type \"any\"\n\n(foo: { a: Object }) => {}\n// Message: Unexpected use of weak type \"Object\"\n\n(foo: any[]) => {}\n// Message: Unexpected use of weak type \"any\"\n\ntype Foo = any\n// Message: Unexpected use of weak type \"any\"\n\ntype Foo = Function\n// Message: Unexpected use of weak type \"Function\"\n\ntype Foo = { a: any }\n// Message: Unexpected use of weak type \"any\"\n\ntype Foo = { a: Object }\n// Message: Unexpected use of weak type \"Object\"\n\ntype Foo = { (a: Object): string }\n// Message: Unexpected use of weak type \"Object\"\n\ntype Foo = { (a: string): Function }\n// Message: Unexpected use of weak type \"Function\"\n\nfunction foo(thing: any) {}\n// Message: Unexpected use of weak type \"any\"\n\nfunction foo(thing: Object) {}\n// Message: Unexpected use of weak type \"Object\"\n\nvar foo: Function\n// Message: Unexpected use of weak type \"Function\"\n\nvar foo: Object\n// Message: Unexpected use of weak type \"Object\"\n\nclass Foo { props: any }\n// Message: Unexpected use of weak type \"any\"\n\nclass Foo { props: Object }\n// Message: Unexpected use of weak type \"Object\"\n\nvar foo: any\n// Message: Unexpected use of weak type \"any\"\n\n// Options: [{\"Function\":false}]\ntype X = any; type Y = Function; type Z = Object\n// Message: Unexpected use of weak type \"any\"\n// Message: Unexpected use of weak type \"Object\"\n\n// Options: [{\"any\":false,\"Object\":false}]\ntype X = any; type Y = Function; type Z = Object\n// Message: Unexpected use of weak type \"Function\"\n```\n\nThe following patterns are not considered problems:\n\n```js\nfunction foo(thing): string {}\n\nfunction foo(thing): Promise<string> {}\n\nfunction foo(thing): Promise<Promise<string>> {}\n\n(foo?: string) => {}\n\n(foo: ?string) => {}\n\n(foo: { a: string }) => {}\n\n(foo: { a: ?string }) => {}\n\n(foo: string[]) => {}\n\ntype Foo = string\n\ntype Foo = { a: string }\n\ntype Foo = { (a: string): string }\n\nfunction foo(thing: string) {}\n\nvar foo: string\n\nclass Foo { props: string }\n\n// Options: [{\"any\":false,\"Object\":false}]\ntype X = any; type Y = Object\n\n// Options: [{\"Function\":false}]\ntype X = Function\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\nfunction foo(thing): Function {}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-object-type-curly-spacing\"></a>\n### <code>object-type-curly-spacing</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nThis rule enforces consistent spacing inside braces of object types.\n\n<a name=\"eslint-plugin-flowtype-rules-object-type-curly-spacing-options-4\"></a>\n#### Options\n\nThe rule has a string option:\n\n* `\"never\"` (default): disallows spacing inside of braces.\n* `\"always\"`: requires spacing inside of braces.\n\n\nThe following patterns are considered problems:\n\n```js\ntype obj = { \"foo\": \"bar\" }\n// Message: There must be no space after \"{\".\n// Message: There must be no space before \"}\".\n\ntype obj = {\"foo\": \"bar\" }\n// Message: There must be no space before \"}\".\n\ntype obj = {\"foo\": \"bar\", ... }\n// Message: There must be no space before \"}\".\n\ntype obj = {|\"foo\": \"bar\" |}\n// Message: There must be no space before \"|}\".\n\ntype obj = {\"foo\": \"bar\", [key: string]: string }\n// Message: There must be no space before \"}\".\n\ntype obj = {\n\"foo\": \"bar\", [key: string]: string }\n// Message: There must be no space before \"}\".\n\ntype obj = { baz: {\"foo\": \"qux\"}, bar: 4}\n// Message: There must be no space after \"{\".\n\n// Options: [\"always\"]\ntype obj = {\"foo\": \"bar\"}\n// Message: A space is required after \"{\".\n// Message: A space is required before \"}\".\n\n// Options: [\"always\"]\ntype obj = {\"foo\": \"bar\" }\n// Message: A space is required after \"{\".\n\n// Options: [\"always\"]\ntype obj = { baz: {\"foo\": \"qux\"}, bar: 4}\n// Message: A space is required before \"}\".\n// Message: A space is required after \"{\".\n// Message: A space is required before \"}\".\n\n// Options: [\"always\"]\ntype obj = { baz: { \"foo\": \"qux\" }, bar: 4}\n// Message: A space is required before \"}\".\n\n// Options: [\"always\"]\ntype obj = { \"foo\": \"bar\", ...}\n// Message: A space is required before \"}\".\n\n// Options: [\"always\"]\ntype obj = {|\"foo\": \"bar\" |}\n// Message: A space is required after \"{|\".\n\n// Options: [\"always\"]\ntype obj = {\"foo\": \"bar\", [key: string]: string }\n// Message: A space is required after \"{\".\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype obj = {baz: {\"foo\": \"qux\"}, bar: 4}\n\ntype obj = {foo: {\"foo\": \"qux\"}}\n\ntype obj = {foo: \"bar\"}\n\ntype obj = {foo: \"bar\"\n}\n\ntype obj = {\nfoo: \"bar\"}\n\ntype obj = {\nfoo: \"bar\"\n}\n\ntype obj = {\nfoo: \"bar\",\nee: \"bar\",\n}\n\ntype obj = {\nfoo: \"bar\",\nee: \"bar\",\n             }\n\ntype obj = {|\"foo\": \"bar\"|}\n\ntype obj = {\"foo\": \"bar\", [key: string]: string}\n\n// Options: [\"always\"]\ntype obj = { baz: { \"foo\": \"qux\" }, bar: 4 }\n\n// Options: [\"always\"]\ntype obj = {}\n\n// Options: [\"always\"]\ntype obj = {\nfoo: \"bar\"\n}\n\n// Options: [\"always\"]\ntype obj = { baz: 4 }\n\n// Options: [\"always\"]\ntype obj = {| \"foo\": \"bar\" |}\n\n// Options: [\"always\"]\ntype obj = { \"foo\": \"bar\", [key: string]: string }\n\n// Options: [\"always\"]\ntype obj = {  baz: { \"foo\": \"qux\" }, bar: 4  }\n\n// Options: [\"always\"]\ntype obj = {\n  baz: { \"foo\": \"qux\" }, bar: 4\n}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-object-type-delimiter\"></a>\n### <code>object-type-delimiter</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent separators between properties in Flow object types.\n\nThis rule takes one argument.\n\nIf it is `'comma'` then a problem is raised when using `;` as a separator.\n\nIf it is `'semicolon'` then a problem is raised when using `,` as a separator.\n\nThe default value is `'comma'`.\n\n_This rule is ported from `babel/flow-object-type`, however the default option was changed._\n\nThe following patterns are considered problems:\n\n```js\n// Options: [\"semicolon\"]\ntype Foo = { a: Foo, b: Bar }\n// Message: Prefer semicolons to commas in object and class types\n\n// Options: [\"comma\"]\ntype Foo = { a: Foo; b: Bar }\n// Message: Prefer commas to semicolons in object and class types\n\n// Options: [\"semicolon\"]\ntype Foo = { [a: string]: Foo, [b: string]: Bar }\n// Message: Prefer semicolons to commas in object and class types\n\n// Options: [\"comma\"]\ntype Foo = { [a: string]: Foo; [b: string]: Bar }\n// Message: Prefer commas to semicolons in object and class types\n\n// Options: [\"semicolon\"]\ntype Foo = { (): Foo, (): Bar }\n// Message: Prefer semicolons to commas in object and class types\n\n// Options: [\"comma\"]\ntype Foo = { (): Foo; (): Bar }\n// Message: Prefer commas to semicolons in object and class types\n\n// Options: [\"semicolon\"]\ndeclare class Foo { a: Foo, }\n// Message: Prefer semicolons to commas in object and class types\n\n// Options: [\"comma\"]\ndeclare class Foo { a: Foo; }\n// Message: Prefer commas to semicolons in object and class types\n\n// Options: [\"semicolon\"]\ndeclare class Foo { [a: string]: Foo, }\n// Message: Prefer semicolons to commas in object and class types\n\n// Options: [\"comma\"]\ndeclare class Foo { a: Foo; }\n// Message: Prefer commas to semicolons in object and class types\n\n// Options: [\"semicolon\"]\ndeclare class Foo { (): Foo, }\n// Message: Prefer semicolons to commas in object and class types\n\n// Options: [\"comma\"]\ndeclare class Foo { (): Foo; }\n// Message: Prefer commas to semicolons in object and class types\n\n// Options: [\"semicolon\"]\ndeclare class Foo { static (): Foo, }\n// Message: Prefer semicolons to commas in object and class types\n\n// Options: [\"comma\"]\ndeclare class Foo { static (): Foo; }\n// Message: Prefer commas to semicolons in object and class types\n```\n\nThe following patterns are not considered problems:\n\n```js\n// Options: [\"semicolon\"]\ntype Foo = { a: Foo; b: Bar }\n\n// Options: [\"comma\"]\ntype Foo = { a: Foo, b: Bar }\n\n// Options: [\"semicolon\"]\ntype Foo = { [a: string]: Foo; [b: string]: Bar }\n\n// Options: [\"comma\"]\ntype Foo = { [a: string]: Foo, [b: string]: Bar }\n\n// Options: [\"semicolon\"]\ntype Foo = { (): Foo; (): Bar }\n\n// Options: [\"comma\"]\ntype Foo = { (): Foo, (): Bar }\n\ntype Foo = { a: Foo, b: Bar }\n\ntype Foo = { [a: string]: Foo, [b: string]: Bar }\n\ntype Foo = { (): Foo, (): Bar }\n\n// Options: [\"semicolon\"]\ndeclare class Foo { a: Foo; }\n\n// Options: [\"comma\"]\ndeclare class Foo { a: Foo, }\n\n// Options: [\"semicolon\"]\ndeclare class Foo { [a: string]: Foo; }\n\n// Options: [\"comma\"]\ndeclare class Foo { [a: string]: Foo, }\n\n// Options: [\"semicolon\"]\ndeclare class Foo { (): Foo; }\n\n// Options: [\"comma\"]\ndeclare class Foo { (): Foo, }\n\n// Options: [\"semicolon\"]\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype Foo = { a: Foo, b: Bar }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-quotes\"></a>\n### <code>quotes</code>\n\nEnforces single quotes or double quotes around string literals.\n\n<a name=\"eslint-plugin-flowtype-rules-quotes-options-5\"></a>\n#### Options\n\nThe rule has string options of:\n\n* `\"double\"` (default) requires double quotes around string literals.\n* `\"single\"` requires single quotes around string literals.\n\nThe following patterns are considered problems:\n\n```js\ntype T = 'hi'\n// Message: String literals must use double quote.\n\n// Options: [\"double\"]\ntype T = { test: 'hello' | 'test' }\n// Message: String literals must use double quote.\n// Message: String literals must use double quote.\n\n// Options: [\"double\"]\ntype T = { test: \"hello\" | 'test', t: 'hello' }\n// Message: String literals must use double quote.\n// Message: String literals must use double quote.\n\n// Options: [\"single\"]\ntype T = \"hi\"\n// Message: String literals must use single quote.\n\n// Options: [\"single\"]\ntype T = { test: \"hello\" | \"test\" }\n// Message: String literals must use single quote.\n// Message: String literals must use single quote.\n\n// Options: [\"single\"]\ntype T = { test: \"hello\" | 'test', t: 'hello' }\n// Message: String literals must use single quote.\n```\n\nThe following patterns are not considered problems:\n\n```js\n// Options: [\"double\"]\ntype T = \"hi\"\n\n// Options: [\"double\"]\ntype T = { test: \"hello\" | \"test\" }\n\n// Options: [\"double\"]\ntype T = { test: \"hello\" | \"test\", t: \"hello\" }\n\n// Options: [\"single\"]\ntype FooType = 'hi'\n\n// Options: [\"single\"]\ntype T = { test: 'hello' | 'test' }\n\n// Options: [\"single\"]\ntype T = { test: 'hello' | 'test', t: 'hello' }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-compound-type-alias\"></a>\n### <code>require-compound-type-alias</code>\n\nRequires to make a type alias for all [union](https://flow.org/en/docs/types/unions/) and [intersection](https://flow.org/en/docs/types/intersections/) types. If these are used in \"raw\" forms it might be tempting to just copy & paste them around the code. However, this brings sort of a source code pollution and unnecessary changes on several parts when these compound types need to be changed.\n\n<a name=\"eslint-plugin-flowtype-rules-require-compound-type-alias-options-6\"></a>\n#### Options\n\nThe rule has two options:\n\n1. a string option\n\n* `\"always\"` (default)\n* `\"never\"`\n\n2. an object\n\n```js\n{\n  \"rules\": {\n    \"flowtype/require-compound-type-alias\": [\n      2,\n      \"always\",\n      {\n        \"allowNull\": true\n      }\n    ]\n  }\n}\n```\n\n* `allowNull` allows compound types where one of the members is a `null`, e.g. `string | null`.\n\nThe following patterns are considered problems:\n\n```js\n// Options: [\"always\",{\"allowNull\":false}]\nconst foo: string | null = null;\n// Message: All union types must be declared with named type alias.\n\nfunction foo(bar: \"A\" | \"B\") {}\n// Message: All union types must be declared with named type alias.\n\nconst foo: \"A\" | \"B\" = \"A\";\n// Message: All union types must be declared with named type alias.\n\ntype Foo = { bar: \"A\" | \"B\" };\n// Message: All union types must be declared with named type alias.\n\nfunction foo(bar: { n: number } | { s: string }) {}\n// Message: All union types must be declared with named type alias.\n\nfunction foo(bar: { n: number } & { s: string }) {}\n// Message: All intersection types must be declared with named type alias.\n\nconst foo: { n: number } & { s: string } = { n: 0, s: \"\" };\n// Message: All intersection types must be declared with named type alias.\n\ntype Foo = { bar: { n: number } & { s: string } };\n// Message: All intersection types must be declared with named type alias.\n\nfunction foo(bar: { n: number } & { s: string }) {}\n// Message: All intersection types must be declared with named type alias.\n```\n\nThe following patterns are not considered problems:\n\n```js\nconst foo: string | null = null;\n\n// Options: [\"always\",{\"allowNull\":true}]\nconst foo: string | null = null;\n\ntype Foo = \"A\" | \"B\";\n\ntype Bar = \"A\" | \"B\"; function foo(bar: Bar) {}\n\ntype Foo = { disjoint: \"A\", n: number } | { disjoint: \"B\", s: string };\n\ntype Foo = { n: number } & { s: string };\n\ntype Bar = { n: number } & { s: string }; function foo(bar: Bar) {}\n\n// Options: [\"never\"]\nfunction foo(bar: \"A\" | \"B\") {}\n\n// Options: [\"never\"]\nfunction foo(bar: { n: number } & { s: string }) {}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-exact-type\"></a>\n### <code>require-exact-type</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nThis rule enforces [exact object types](https://flow.org/en/docs/types/objects/#toc-exact-object-types).\n\n<a name=\"eslint-plugin-flowtype-rules-require-exact-type-options-7\"></a>\n#### Options\n\nThe rule has one string option:\n\n* `\"always\"` (default): Report all object type definitions that aren't exact.\n* `\"never\"`: Report all object type definitions that are exact.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/require-exact-type\": [\n      2,\n      \"always\"\n    ]\n  }\n}\n\n{\n  \"rules\": {\n    \"flowtype/require-exact-type\": [\n      2,\n      \"never\"\n    ]\n  }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype foo = {};\n// Message: Object type must be exact.\n\ntype foo = { bar: string };\n// Message: Object type must be exact.\n\n// Options: [\"always\"]\ntype foo = Array<{bar: string}>;\n// Message: Object type must be exact.\n\n// Options: [\"always\"]\n(foo: Array<{bar: string}>) => {};\n// Message: Object type must be exact.\n\n// Options: [\"always\"]\ninterface StackFrame {\n          colno?: number;\n          lineno?: number;\n          filename?: string;\n          function?: { name: string };\n      }\n// Message: Object type must be exact.\n\n// Options: [\"never\"]\ntype foo = {| |};\n// Message: Object type must not be exact.\n\n// Options: [\"never\"]\ntype foo = {| bar: string |};\n// Message: Object type must not be exact.\n\n// Options: [\"never\"]\ntype foo = { bar: {| baz: string |} };\n// Message: Object type must not be exact.\n\n// Options: [\"never\"]\ntype foo = Array<{| bar: string |}>;\n// Message: Object type must not be exact.\n\n// Options: [\"never\"]\n(foo: Array<{| bar: string |}>) => {};\n// Message: Object type must not be exact.\n\n// Options: [\"never\"]\ninterface StackFrame {\n          colno?: number;\n          lineno?: number;\n          filename?: string;\n          function?: {| name: string |};\n      }\n// Message: Object type must not be exact.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype foo = {| |};\n\ntype foo = {| bar: string |};\n\ntype foo = { [key: string]: string };\n\ntype foo = number;\n\n// Options: [\"always\"]\ntype foo = {| |};\n\n// Options: [\"always\"]\ntype foo = {| bar: string |};\n\n// Options: [\"always\"]\ntype foo = {| bar: {| baz: string |} |};\n\n// Options: [\"always\"]\ntype foo = Array<{| bar: string |}>;\n\n// Options: [\"always\"]\ntype foo = number;\n\n// Options: [\"always\"]\ninterface StackFrame {\n          colno?: number;\n          lineno?: number;\n          filename?: string;\n          function?: {| name: string |};\n      }\n\n// Options: [\"always\"]\ndeclare class MyEvent extends Event {\n        key: string\n      }\n\n// Options: [\"never\"]\ntype foo = { };\n\n// Options: [\"never\"]\ntype foo = { bar: string };\n\n// Options: [\"never\"]\ntype foo = { bar: { baz: string } };\n\n// Options: [\"never\"]\ntype foo = Array<{bar: string}>;\n\n// Options: [\"never\"]\ntype foo = number;\n\n// Options: [\"always\"]\ninterface StackFrame {\n          colno?: number;\n          lineno?: number;\n          filename?: string;\n          function?: {| name: string |};\n      }\n\ntype A = { a: string, ... }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-indexer-name\"></a>\n### <code>require-indexer-name</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nThis rule validates Flow object indexer name.\n\n<a name=\"eslint-plugin-flowtype-rules-require-indexer-name-options-8\"></a>\n#### Options\n\nThe rule has a string option:\n\n* `\"never\"` (default): Never report files that are missing an indexer key name.\n* `\"always\"`: Always report files that are missing an indexer key name.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/require-indexer-name\": [\n      2,\n      \"always\"\n    ]\n  }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype foo = { [string]: number };\n// Message: All indexers must be declared with key name.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype foo = { [key: string]: number };\n\n// Options: [\"never\"]\ntype foo = { [key: string]: number };\n\n// Options: [\"never\"]\ntype foo = { [string]: number };\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-inexact-type\"></a>\n### <code>require-inexact-type</code>\n\nThis rule enforces explicit inexact object types.\n\n<a name=\"eslint-plugin-flowtype-rules-require-inexact-type-options-9\"></a>\n#### Options\n\nThe rule has one string option:\n\n- `\"always\"` (default): Report all object type definitions that aren't explicit inexact, but ignore exact objects.\n- `\"never\"`: Report all object type definitions that are explicit inexact.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/require-inexact-type\": [\n      2,\n      \"always\"\n    ]\n  }\n}\n\n{\n  \"rules\": {\n    \"flowtype/require-inexact-type\": [\n      2,\n      \"never\"\n    ]\n  }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype foo = {};\n// Message: Type must be explicit inexact.\n\ntype foo = { bar: string };\n// Message: Type must be explicit inexact.\n\n// Options: [\"always\"]\ntype foo = {};\n// Message: Type must be explicit inexact.\n\n// Options: [\"always\"]\ntype foo = { bar: string };\n// Message: Type must be explicit inexact.\n\n// Options: [\"never\"]\ntype foo = {...};\n// Message: Type must not be explicit inexact.\n\n// Options: [\"never\"]\ntype foo = { bar: string, ... };\n// Message: Type must not be explicit inexact.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype foo = { foo: string, ... };\n\ninterface Foo { foo: string }\n\ndeclare class Foo { foo: string }\n\ntype foo = {| |};\n\ntype foo = {| bar: string |};\n\ntype foo = { [key: string]: string, ... };\n\ntype foo = number;\n\n// Options: [\"always\"]\ntype foo = {| |};\n\n// Options: [\"always\"]\ntype foo = {...};\n\n// Options: [\"always\"]\ntype foo = { bar: string, ... };\n\n// Options: [\"always\"]\ntype foo = {| bar: string |};\n\n// Options: [\"always\"]\ntype foo = number;\n\n// Options: [\"never\"]\ntype foo = { };\n\n// Options: [\"never\"]\ntype foo = {| |};\n\n// Options: [\"never\"]\ntype foo = { bar: string };\n\n// Options: [\"never\"]\ntype foo = {| bar: string |};\n\n// Options: [\"never\"]\ntype foo = number;\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-parameter-type\"></a>\n### <code>require-parameter-type</code>\n\nRequires that all function parameters have type annotations.\n\n<a name=\"eslint-plugin-flowtype-rules-require-parameter-type-options-10\"></a>\n#### Options\n\nYou can skip all arrow functions by providing the `excludeArrowFunctions` option with `true`.\n\nAlternatively, you can want to exclude only concise arrow functions (e.g. `x => x * 2`). Provide `excludeArrowFunctions` with `expressionsOnly` for this.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-parameter-type\": [\n            2,\n            {\n              \"excludeArrowFunctions\": true\n            }\n        ]\n    }\n}\n\n{\n    \"rules\": {\n        \"flowtype/require-parameter-type\": [\n            2,\n            {\n              \"excludeArrowFunctions\": \"expressionsOnly\"\n            }\n        ]\n    }\n}\n```\n\nYou can exclude parameters that match a certain regex by using `excludeParameterMatch`.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-parameter-type\": [\n            2,\n            {\n              \"excludeParameterMatch\": \"^_\"\n            }\n        ]\n    }\n}\n```\n\nThis excludes all parameters that start with an underscore (`_`).\nThe default pattern is `a^`, which doesn't match anything, i.e., all parameters are checked.\n\nThe following patterns are considered problems:\n\n```js\n(foo) => {}\n// Message: Missing \"foo\" parameter type annotation.\n\nfunction x(foo) {}\n// Message: Missing \"foo\" parameter type annotation.\n\n// Options: [{\"excludeArrowFunctions\":true}]\nfunction x(foo) {}\n// Message: Missing \"foo\" parameter type annotation.\n\n(foo = 'FOO') => {}\n// Message: Missing \"foo\" parameter type annotation.\n\n(...foo) => {}\n// Message: Missing \"foo\" parameter type annotation.\n\n({foo}) => {}\n// Message: Missing \"{foo}\" parameter type annotation.\n\n([foo]) => {}\n// Message: Missing \"[foo]\" parameter type annotation.\n\n({foo = 1} = {}) => {}\n// Message: Missing \"{foo = 1}\" parameter type annotation.\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\n// @flow\n(foo) => {}\n// Message: Missing \"foo\" parameter type annotation.\n\n// Options: [{\"excludeArrowFunctions\":\"expressionsOnly\"}]\n(foo) => {}\n// Message: Missing \"foo\" parameter type annotation.\n\n// Options: [{\"excludeArrowFunctions\":\"expressionsOnly\"}]\nfunction x(foo) {}\n// Message: Missing \"foo\" parameter type annotation.\n\n// Options: [{\"excludeParameterMatch\":\"^_\"}]\n(_foo: number, bar) => {}\n// Message: Missing \"bar\" parameter type annotation.\n\n// Options: [{\"excludeParameterMatch\":\"^_\"}]\n(_foo, bar) => {}\n// Message: Missing \"bar\" parameter type annotation.\n```\n\nThe following patterns are not considered problems:\n\n```js\n(foo: string) => {}\n\n(foo: string = 'FOO') => {}\n\n(...foo: string) => {}\n\nconst f: Foo = (a, b) => 42;\n\n({foo}: {foo: string}) => {}\n\n([foo]: Array) => {}\n\ntype fn = (a: string, b: number) => number;\nconst f: fn = (a, b) => {}\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\n(foo) => {}\n\n// Options: [{\"excludeArrowFunctions\":true}]\n(foo) => {}\n\n// Options: [{\"excludeArrowFunctions\":\"expressionsOnly\"}]\n(foo) => 3\n\n// Options: [{\"excludeParameterMatch\":\"^_\"}]\n(_foo, bar: string) => {}\n\n// Options: [{\"excludeParameterMatch\":\"^_\"}]\n(_foo: number, bar: string) => {}\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\n(foo) => {}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-readonly-react-props\"></a>\n### <code>require-readonly-react-props</code>\n\nThis rule validates that React props are marked as `$ReadOnly`. React props are immutable and modifying them could lead to unexpected results. Marking prop shapes as `$ReadOnly` avoids these issues.\n\nThe rule tries its best to work with both class and functional components. For class components, it does a fuzzy check for one of \"Component\", \"PureComponent\", \"React.Component\" and \"React.PureComponent\". It doesn't actually infer that those identifiers resolve to a proper `React.Component` object.\n\nFor example, this will NOT be checked:\n\n```js\nimport MyReact from 'react';\nclass Foo extends MyReact.Component { }\n```\n\nAs a result, you can safely use other classes without getting warnings from this rule:\n\n```js\nclass MyClass extends MySuperClass { }\n```\n\nReact's functional components are hard to detect statically. The way it's done here is by searching for JSX within a function. When present, a function is considered a React component:\n\n```js\n// this gets checked\ntype Props = { };\nfunction MyComponent(props: Props) {\n    return <p />;\n}\n\n// this doesn't get checked since no JSX is present in a function\ntype Options = { };\nfunction SomeHelper(options: Options) {\n    // ...\n}\n\n// this doesn't get checked since no JSX is present directly in a function\nfunction helper() { return <p /> }\nfunction MyComponent(props: Props) {\n    return helper();\n}\n```\n\nThe rule only works for locally defined props that are marked with a `$ReadOnly` or using covariant notation. It doesn't work with imported props:\n\n```js\n// the rule has no way of knowing whether ImportedProps are read-only\nimport { type ImportedProps } from './somewhere';\nclass Foo extends React.Component<ImportedProps> { }\n\n\n// the rule also checks for covariant properties\ntype Props = {|\n    +foo: string\n|};\nclass Bar extends React.Component<Props> { }\n\n// this fails because the object is not fully read-only\ntype Props = {|\n    +foo: string,\n    bar: number,\n|};\nclass Bar extends React.Component<Props> { }\n\n// this fails because spreading makes object mutable (as of Flow 0.98)\n// https://github.com/gajus/eslint-plugin-flowtype/pull/400#issuecomment-489813899\ntype Props = {|\n    +foo: string,\n    ...bar,\n|};\nclass Bar extends React.Component<Props> { }\n```\n\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-readonly-react-props\": 2\n    }\n}\n```\n\n\nOptionally, you can enable support for [implicit exact Flow types](https://medium.com/flow-type/on-the-roadmap-exact-objects-by-default-16b72933c5cf) (useful when using `exact_by_default=true` Flow option):\n\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-readonly-react-props\": [\n            2,\n            {\n                \"useImplicitExactTypes\": true\n            }\n        ]\n    }\n}\n```\n\n\nThe following patterns are considered problems:\n\n```js\ntype Props = { }; class Foo extends React.Component<Props> { }\n// Message: Props must be $ReadOnly\n\ntype OtherProps = { foo: string }; class Foo extends React.Component<OtherProps> { }\n// Message: OtherProps must be $ReadOnly\n\nclass Foo extends React.Component<{}> { }\n// Message: Foo class props must be $ReadOnly\n\ntype Props = { bar: {} }; class Foo extends React.Component<Props, State> { }\n// Message: Props must be $ReadOnly\n\ntype Props = { }; class Foo extends Component<Props> { }\n// Message: Props must be $ReadOnly\n\ntype Props = { }; class Foo extends PureComponent<Props> { }\n// Message: Props must be $ReadOnly\n\nexport type Props = {}; class Foo extends Component<Props> { }\n// Message: Props must be $ReadOnly\n\ntype Props = {| foo: string |}; class Foo extends Component<Props> { }\n// Message: Props must be $ReadOnly\n\ntype Props = {| foo: string |} | {| bar: number |}; class Foo extends Component<Props> { }\n// Message: Props must be $ReadOnly\n\n// Options: [{\"useImplicitExactTypes\":true}]\ntype Props = { foo: string } | { bar: number }; class Foo extends Component<Props> { }\n// Message: Props must be $ReadOnly\n\ntype Props = {| +foo: string, ...bar |}; class Foo extends Component<Props> { }\n// Message: Props must be $ReadOnly\n\ntype Props = {| +foo: string, -bar: number |}; class Foo extends Component<Props> { }\n// Message: Props must be $ReadOnly\n\ntype Props = { }; function Foo(props: Props) { return <p /> }\n// Message: Props must be $ReadOnly\n\ntype Props = { }; function Foo(props: Props) { return foo ? <p /> : <span /> }\n// Message: Props must be $ReadOnly\n\nfunction Foo(props: {}) { return <p /> }\n// Message: Foo component props must be $ReadOnly\n\nexport type Props = {}; function Foo(props: Props) { return <p /> }\n// Message: Props must be $ReadOnly\n```\n\nThe following patterns are not considered problems:\n\n```js\nclass Foo extends React.Component<$ReadOnly<{}>> { }\n\ntype Props = $ReadOnly<{}>; class Foo extends React.Component<Props> { }\n\ntype Props = $ReadOnly<{}>; class Foo extends React.PureComponent<Props> { }\n\nclass Foo extends React.Component<$ReadOnly<{}, State>> { }\n\ntype Props = $ReadOnly<{}>; class Foo extends React.Component<Props, State> { }\n\ntype Props = $ReadOnly<{}>; class Foo extends Component<Props> { }\n\ntype Props = $ReadOnly<{}>; class Foo extends PureComponent<Props> { }\n\ntype FooType = {}; class Foo extends Bar<FooType> { }\n\nclass Foo { }\n\nexport type Props = $ReadOnly<{}>; class Foo extends Component<Props, State> { }\n\nexport type Props = $ReadOnly<{}>; export class Foo extends Component<Props> { }\n\ntype Props = {| +foo: string |}; class Foo extends Component<Props> { }\n\ntype Props = {| +foo: string, +bar: number |}; class Foo extends Component<Props> { }\n\ntype Props = {| +foo: string |} | {| +bar: number |}; class Foo extends Component<Props> { }\n\n// Options: [{\"useImplicitExactTypes\":true}]\ntype Props = { +foo: string } | { +bar: number }; class Foo extends Component<Props> { }\n\ntype Props = $FlowFixMe; class Foo extends Component<Props> { }\n\ntype Props = {||}; class Foo extends Component<Props> { }\n\n// Options: [{\"useImplicitExactTypes\":true}]\ntype Props = {||}; class Foo extends Component<Props> { }\n\n// Options: [{\"useImplicitExactTypes\":true}]\ntype Props = {}; class Foo extends Component<Props> { }\n\nclass Foo extends Component<{||}> { }\n\n// Options: [{\"useImplicitExactTypes\":true}]\nclass Foo extends Component<{||}> { }\n\n// Options: [{\"useImplicitExactTypes\":true}]\nclass Foo extends Component<{}> { }\n\nclass Foo extends React.Component<UnknownProps> { }\n\nimport { type Props } from \"file\"; class Foo extends React.Component<Props> { }\n\ntype Props = {}; function Foo() { }\n\ntype Props = $ReadOnly<{}>; function Foo(props: Props) { }\n\ntype Props = {}; function Foo(props: OtherProps) { }\n\nfunction Foo() { return <p /> }\n\nfunction Foo(props: $FlowFixMe) { return <p /> }\n\nfunction Foo(props: {||}) { return <p /> }\n\n// Options: [{\"useImplicitExactTypes\":true}]\nfunction Foo(props: {||}) { return <p /> }\n\n// Options: [{\"useImplicitExactTypes\":true}]\nfunction Foo(props: {}) { return <p /> }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-return-type\"></a>\n### <code>require-return-type</code>\n\nRequires that functions have return type annotation.\n\n<a name=\"eslint-plugin-flowtype-rules-require-return-type-options-11\"></a>\n#### Options\n\nYou can skip all arrow functions by providing the `excludeArrowFunctions` option with `true`.\n\nAlternatively, you can exclude a concise arrow function (e.g. `() => 2`). Provide `excludeArrowFunctions` with `expressionsOnly` for this.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-return-type\": [\n            2,\n            \"always\",\n            {\n              \"excludeArrowFunctions\": true\n            }\n        ]\n    }\n}\n\n{\n    \"rules\": {\n        \"flowtype/require-return-type\": [\n            2,\n            \"always\",\n            {\n              \"excludeArrowFunctions\": \"expressionsOnly\"\n            }\n        ]\n    }\n}\n```\n\nYou can exclude or include specific tests with the `includeOnlyMatching` and `excludeMatching` rules.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-return-type\": [\n            2,\n            \"always\",\n            {\n              \"includeOnlyMatching\": [\n                  \"^F.*\",\n                  \"Ba(r|z)\"\n              ]\n            }\n        ]\n    }\n}\n\n{\n    \"rules\": {\n        \"flowtype/require-return-type\": [\n            2,\n            \"always\",\n            {\n              \"excludeMatching\": [\n                  \"^F.*\",\n                  \"Ba(r|z)\"\n              ]\n            }\n        ]\n    }\n}\n\n```\n\nBoth rules take an array that can contain either strings or valid RegExp statements.\n\nThe following patterns are considered problems:\n\n```js\n(foo) => { return \"foo\"; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\"]\n(foo) => { return \"foo\"; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\"]\n(foo) => \"foo\"\n// Message: Missing return type annotation.\n\n(foo) => ({})\n// Message: Missing return type annotation.\n\n/* @flow */\n(foo) => { return 1; }\n// Message: Missing return type annotation.\n\n(foo): undefined => { return; }\n// Message: Must not annotate undefined return type.\n\n(foo): void => { return; }\n// Message: Must not annotate undefined return type.\n\n(foo): undefined => { return undefined; }\n// Message: Must not annotate undefined return type.\n\n(foo): void => { return void 0; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo): undefined => { return; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo): void => { return; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo) => { return; }\n// Message: Must annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo): undefined => { return undefined; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo) => { return undefined; }\n// Message: Must annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo) => { return void 0; }\n// Message: Must annotate undefined return type.\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\n// @flow\n(foo) => { return 1; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\n// @flow\n (foo) => { return undefined; }\n// Message: Must annotate undefined return type.\n\n// Options: [\"always\"]\nasync () => { return 2; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nasync () => {}\n// Message: Must annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nasync function x() {}\n// Message: Must annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\nasync (): Promise<void> => { return; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\nasync (): Promise<undefined> => { return; }\n// Message: Must not annotate undefined return type.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nclass Test { constructor() { } }\n// Message: Must annotate undefined return type.\n\nclass Test { foo() { return 42; } }\n// Message: Missing return type annotation.\n\nclass Test { foo = () => { return 42; } }\n// Message: Missing return type annotation.\n\nclass Test { foo = () => 42; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\"]\nfunction* x() {}\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"excludeArrowFunctions\":\"expressionsOnly\"}]\n() => { return 3; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"excludeArrowFunctions\":\"expressionsOnly\"}]\nasync () => { return 4; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"includeOnlyMatching\":[\"bar\"]}]\nfunction foo() { return 42; }\nfunction bar() { return 42; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"includeOnlyMatching\":[\"bar\"]}]\nconst foo = () => { return 42; };\nconst bar = () => { return 42; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"includeOnlyMatching\":[\"bar\"]}]\nconst foo = { bar() { return 42; }, foobar: function() { return 42; } }\n// Message: Missing return type annotation.\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"excludeMatching\":[\"bar\"]}]\nconst foo = { bar() { return 42; }, baz() { return 42; } }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nfunction * foo() { yield 2; }\n// Message: Missing return type annotation.\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nasync function * foo() { yield 2; }\n// Message: Missing return type annotation.\n```\n\nThe following patterns are not considered problems:\n\n```js\nreturn;\n\n(foo): string => {}\n\nconst f: Foo = (a, b) => 42;\n\n// Options: [\"always\"]\n(foo): string => {}\n\ntype fn = (a: string, b: number) => number;\nconst f: fn = (a, b) => { return 42; }\n\n(foo) => { return; }\n\n(foo): Object => ( {} )\n\n(foo) => { return undefined; }\n\n(foo) => { return void 0; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo): undefined => { return; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo): void => { return; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo) => { return; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo) => { return undefined; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"never\"}]\n(foo) => { return void 0; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo): undefined => { return undefined; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n(foo): void => { return void 0; }\n\n// Options: [\"always\"]\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\n(foo) => { return 1; }\n\n// Options: [\"always\"]\n/* @noflow */\n(foo) => { return 1; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\n(foo) => { return undefined; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nasync function doThing(): Promise<void> {}\n\n// Options: [\"always\",{\"annotateUndefined\":\"ignore\"}]\nasync function doThing(): Promise<void> {}\n\n// Options: [\"always\",{\"annotateUndefined\":\"ignore\"}]\nasync function doThing() {}\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nfunction* doThing(): Generator<number, void, void> { yield 2; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\",\"excludeMatching\":[\"constructor\"]}]\nclass Test { constructor() { } }\n\nclass Test { constructor() { } }\n\n// Options: [\"always\",{\"excludeMatching\":[\"foo\"]}]\nclass Test { foo() { return 42; } }\n\n// Options: [\"always\",{\"excludeMatching\":[\"foo\"]}]\nclass Test { foo = () => { return 42; } }\n\n// Options: [\"always\",{\"excludeMatching\":[\"foo\"]}]\nclass Test { foo = () => 42; }\n\nclass Test { foo = (): number => { return 42; } }\n\nclass Test { foo = (): number => 42; }\n\nasync (foo): Promise<number> => { return 3; }\n\n// Options: [\"always\",{\"excludeArrowFunctions\":true}]\n() => 3\n\n// Options: [\"always\",{\"excludeArrowFunctions\":true}]\n() => { return 4; }\n\n// Options: [\"always\",{\"excludeArrowFunctions\":true}]\n() => undefined\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\",\"excludeArrowFunctions\":true}]\n() => undefined\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\",\"excludeArrowFunctions\":true}]\n() => { return undefined; }\n\n// Options: [\"always\",{\"excludeArrowFunctions\":\"expressionsOnly\"}]\n() => 3\n\n// Options: [\"always\",{\"excludeArrowFunctions\":\"expressionsOnly\"}]\nasync () => 3\n\n// Options: [\"always\",{\"excludeMatching\":[\"foo\"]}]\nfunction foo() { return 42; }\n\n// Options: [\"always\",{\"includeOnlyMatching\":[\"bar\"]}]\nfunction foo() { return 42; }\n\n// Options: [\"always\",{\"excludeMatching\":[\"bar\"]}]\nfunction foo(): number { return 42; }\nfunction bar() { return 42; }\n\n// Options: [\"always\",{\"includeOnlyMatching\":[\"foo\",\"baz\"]}]\nfunction foo(): number { return 42; }\nfunction bar() { return 42; }\n\n// Options: [\"always\",{\"excludeMatching\":[\"^b.*\",\"qux\"]}]\nfunction foo(): number { return 42; }\nfunction bar() { return 42; }\n\n// Options: [\"always\",{\"includeOnlyMatching\":[\"^f.*\"]}]\nfunction foo(): number { return 42; }\nfunction bar() { return 42; }\n\n// Options: [\"always\",{\"includeOnlyMatching\":[\"bar\"]}]\nconst foo = { baz() { return 42; } }\n\n// Options: [\"always\",{\"excludeMatching\":[\"bar\"]}]\nconst foo = { bar() { return 42; } }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nfunction * foo(): Iterable<number> { yield 2; }\n\n// Options: [\"always\",{\"annotateUndefined\":\"always\"}]\nasync function * foo(): AsyncIterable<number> { yield 2; }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-types-at-top\"></a>\n### <code>require-types-at-top</code>\n\nRequires all type declarations to be at the top of the file, after any import declarations.\n\n<a name=\"eslint-plugin-flowtype-rules-require-types-at-top-options-12\"></a>\n#### Options\n\nThe rule has a string option:\n\n* `\"never\"`\n* `\"always\"`\n\nThe default value is `\"always\"`.\n\nThe following patterns are considered problems:\n\n```js\nconst foo = 3;\ntype Foo = number;\n// Message: All type declaration must be at the top of the file, after any import declarations.\n\nconst foo = 3;\nopaque type Foo = number;\n// Message: All type declaration must be at the top of the file, after any import declarations.\n\nconst foo = 3;\nexport type Foo = number;\n// Message: All type declaration must be at the top of the file, after any import declarations.\n\nconst foo = 3;\nexport opaque type Foo = number;\n// Message: All type declaration must be at the top of the file, after any import declarations.\n\nconst foo = 3;\ntype Foo = number | string;\n// Message: All type declaration must be at the top of the file, after any import declarations.\n\nimport bar from \"./bar\";\nconst foo = 3;\ntype Foo = number;\n// Message: All type declaration must be at the top of the file, after any import declarations.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype Foo = number;\nconst foo = 3;\n\nopaque type Foo = number;\nconst foo = 3;\n\nexport type Foo = number;\nconst foo = 3;\n\nexport opaque type Foo = number;\nconst foo = 3;\n\ntype Foo = number;\nconst foo = 3;\n\nimport bar from \"./bar\";\ntype Foo = number;\n\ntype Foo = number;\nimport bar from \"./bar\";\n\n// Options: [\"never\"]\nconst foo = 3;\ntype Foo = number;\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-valid-file-annotation\"></a>\n### <code>require-valid-file-annotation</code>\n\nThis rule validates Flow file annotations.\n\nThis rule can optionally report missing or missed placed annotations, common typos (e.g. `// @floww`), and enforce a consistent annotation style.\n\n<a name=\"eslint-plugin-flowtype-rules-require-valid-file-annotation-options-13\"></a>\n#### Options\n\nThe rule has a string option:\n\n* `\"never\"` (default): Never report files that are missing an `@flow` annotation.\n* `\"always\"`: Always report files that are missing an `@flow` annotation\n\nThis rule has an object option:\n\n* `\"annotationStyle\"` - Enforce a consistent file annotation style.\n    * `\"none\"` (default): Either annotation style is accepted.\n    * `\"line\"`: Require single line annotations (i.e. `// @flow`).\n    * `\"block\"`: Require block annotations (i.e. `/* @flow */`).\n\n* `\"strict\"` - Enforce a strict flow file annotation.\n    * `false` (default): strict flow annotation is not required.\n    * `true`: Require strict flow annotation (i.e. `// @flow strict`).\n\n```js\n{\n  \"rules\": {\n    \"flowtype/require-valid-file-annotation\": [\n      2,\n      \"always\"\n    ]\n  }\n}\n\n{\n  \"rules\": {\n    \"flowtype/require-valid-file-annotation\": [\n      2,\n      \"always\", {\n        \"annotationStyle\": \"block\",\n        \"strict\": true,\n      }\n    ]\n  }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\n// Options: [\"always\"]\n#!/usr/bin/env node\n// Message: Flow file annotation is missing.\n\n// Options: [\"always\"]\n#!/usr/bin/env node\na;\n// Message: Flow file annotation is missing.\n\n;// @flow\n// Message: Flow file annotation not at the top of the file.\n\n;\n// @flow\n// Message: Flow file annotation not at the top of the file.\n\n// @Flow\n// Message: Malformed Flow file annotation.\n\n// @NoFlow\n// Message: Malformed Flow file annotation.\n\n// @Noflow\n// Message: Malformed Flow file annotation.\n\n// @floweeeeeee\n// Message: Misspelled or malformed Flow file annotation.\n\n// @nofloweeeeeee\n// Message: Misspelled or malformed Flow file annotation.\n\n// Options: [\"always\"]\na;\n// Message: Flow file annotation is missing.\n\n// Options: [\"always\",{\"annotationStyle\":\"line\"}]\n/* @flow */\n// Message: Flow file annotation style must be `// @flow`\n\n// Options: [\"always\",{\"annotationStyle\":\"block\"}]\n// @flow\n// Message: Flow file annotation style must be `/* @flow */`\n\n// Options: [\"always\",{\"annotationStyle\":\"block\"}]\n// @flow\n// Message: Flow file annotation style must be `/* @flow */`\n\n// Options: [\"always\",{\"annotationStyle\":\"line\",\"strict\":true}]\n// @flow\n// Message: Strict Flow file annotation is required, must be `// @flow strict`\n\n// Options: [\"always\",{\"annotationStyle\":\"line\"}]\n/* @noflow */\n// Message: Flow file annotation style must be `// @noflow`\n\n// Options: [\"always\",{\"annotationStyle\":\"block\"}]\n// @noflow\n// Message: Flow file annotation style must be `/* @noflow */`\n\n// Options: [\"always\"]\na;\n// Message: Flow file annotation is missing.\n\n// Options: [\"always\",{\"annotationStyle\":\"block\"}]\na;\n// Message: Flow file annotation is missing.\n\n// Options: [\"always\",{\"annotationStyle\":\"line\",\"strict\":true}]\na;\n// Message: Flow file annotation is missing.\n\n// Options: [\"always\",{\"annotationStyle\":\"line\",\"strict\":true}]\n// @flow\na;\nb;\n// Message: Strict Flow file annotation is required, must be `// @flow strict`\n\n// Options: [\"never\",{\"annotationStyle\":\"line\"}]\n/* @flow */\na;\nb;\n// Message: Flow file annotation style must be `// @flow`\n\n// Options: [\"never\",{\"annotationStyle\":\"line\"}]\n/* @flow strict */\na;\nb;\n// Message: Flow file annotation style must be `// @flow strict`\n```\n\nThe following patterns are not considered problems:\n\n```js\na;\n\n// @flow\na;\n\n//@flow\na;\n\n//**@flow\na;\n\n/* foo @flow bar */\na;\n\n\n\n// @flow\na;\n\n// @flow\n// @FLow\n\n// @noflow\na;\n\n// Options: [\"always\"]\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\na;\n\n// Options: [\"always\",{\"annotationStyle\":\"line\"}]\n// @flow\n\n// Options: [\"always\",{\"annotationStyle\":\"line\",\"strict\":true}]\n// @noflow\n\n// Options: [\"always\",{\"annotationStyle\":\"line\",\"strict\":true}]\n// @flow strict\n\n// Options: [\"never\",{\"annotationStyle\":\"none\"}]\n// @function\n\n// Options: [\"never\"]\n// @fixable\n\n// Options: [\"always\",{\"annotationStyle\":\"block\"}]\n/* @flow */\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-require-variable-type\"></a>\n### <code>require-variable-type</code>\n\nRequires that all variable declarators have type annotations.\n\n<a name=\"eslint-plugin-flowtype-rules-require-variable-type-options-14\"></a>\n#### Options\n\nYou can exclude variables that match a certain regex by using `excludeVariableMatch`.\n\nThis excludes all parameters that start with an underscore (`_`).\nThe default pattern is `a^`, which doesn't match anything, i.e., all parameters are checked.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-variable-type\": [\n            2,\n            {\n              \"excludeVariableMatch\": \"^_\"\n            }\n        ]\n    }\n}\n```\n\n\nYou can choose specific variable types (`var`, `let`, and `const`) to ignore using `excludeVariableTypes`.\n\nThis excludes `var` and `let` declarations from needing type annotations, but forces `const` declarations to have it.\nBy default, all declarations are checked.\n\n```js\n{\n    \"rules\": {\n        \"flowtype/require-variable-type\": [\n            2,\n            {\n              \"excludeVariableTypes\": {\n                \"var\": true,\n                \"let\": true,\n                \"const\": false,\n              }\n            }\n        ]\n    }\n}\n```\n\n\n\nThe following patterns are considered problems:\n\n```js\nvar foo = \"bar\"\n// Message: Missing \"foo\" variable type annotation.\n\nvar foo : string = \"bar\", bar = 1\n// Message: Missing \"bar\" variable type annotation.\n\n// Options: [{\"excludeVariableMatch\":\"^_\"}]\nvar _foo = \"bar\", bar = 1\n// Message: Missing \"bar\" variable type annotation.\n\n// Options: [{\"excludeVariableTypes\":{\"let\":false,\"var\":true}}]\nvar foo = \"bar\", bar = 1; const oob : string = \"oob\"; let hey = \"yah\"\n// Message: Missing \"hey\" variable type annotation.\n```\n\nThe following patterns are not considered problems:\n\n```js\nvar foo : string = \"bar\"\n\nvar foo : string = \"bar\", bar : number = 1\n\n// Options: [{\"excludeVariableMatch\":\"^_\"}]\nvar _foo = \"bar\", bar : number = 1\n\n// Options: [{\"excludeVariableTypes\":{\"var\":true}}]\nvar foo = \"bar\", bar = 1\n\n// Options: [{\"excludeVariableTypes\":{\"let\":true,\"var\":true}}]\nvar foo = \"bar\", bar = 1; const oob : string = \"oob\"; let hey = \"yah\"\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-semi\"></a>\n### <code>semi</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent use of semicolons after type aliases.\n\nThis rule takes one argument. If it is `'never'` then a problem is raised when there is a semicolon after a type alias. If it is `'always'` then a problem is raised when there is no semicolon after a type alias.\n\nThe default value is `'always'`.\n\nThe following patterns are considered problems:\n\n```js\n// Options: [\"always\"]\nclass Foo { foo: string }\n// Message: Missing semicolon.\n\n// Options: [\"never\"]\nclass Foo { foo: string; }\n// Message: Extra semicolon.\n\n// Options: []\ntype FooType = {}\n// Message: Missing semicolon.\n\n// Options: [\"always\"]\ntype FooType = {}\n// Message: Missing semicolon.\n\n// Options: [\"never\"]\ntype FooType = {};\n// Message: Extra semicolon.\n\n// Options: []\nopaque type FooType = {}\n// Message: Missing semicolon.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype FooType = {};\n\n// Options: [\"always\"]\ntype FooType = {};\n\n// Options: [\"always\"]\n(foo: string) => {}\n\n// Options: [\"always\"]\nclass Foo { foo: string; }\n\n// Options: [\"never\"]\nclass Foo { foo: string }\n\n// Options: [\"always\"]\ntype FooType = { a: number;\n b: string;\n };\n\n// Options: [\"never\"]\ntype FooType = { a: number;\n b: string;\n }\n\n// Options: [\"never\"]\ntype FooType = {}\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype FooType = {}\n\nopaque type FooType = {};\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-sort-keys\"></a>\n### <code>sort-keys</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces natural, case-insensitive sorting of Object annotations.\n\n<a name=\"eslint-plugin-flowtype-rules-sort-keys-options-15\"></a>\n#### Options\n\nThe first option specifies sort order.\n\n* `\"asc\"` (default) - enforce ascending sort order.\n* `\"desc\"` - enforce descending sort order.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/sort-keys\": [\n      2,\n      \"asc\"\n    ]\n  }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype FooType = { a: number, c: number, b: string }\n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n// Options: [\"desc\"]\ntype FooType = { a: number, b: number }\n// Message: Expected type annotations to be in descending order. \"b\" must be before \"a\".\n\n// Options: [\"desc\"]\ntype FooType = { b: number, C: number, a: string }\n// Message: Expected type annotations to be in descending order. \"C\" must be before \"b\".\n\n// Options: [\"asc\"]\ntype FooType = { a: number, c: number, C: number, b: string }\n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"C\".\n\n// Options: [\"asc\"]\ntype FooType = { a: number, C: number, c: number, b: string }\n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n// Options: [\"asc\"]\ntype FooType = { 1: number, 10: number, 2: boolean }\n// Message: Expected type annotations to be in ascending order. \"2\" must be before \"10\".\n\ntype FooType = { a: number, c: number, b: string }\n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          a: number,\n          c: number,\n          b: string,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          a: $ReadOnlyArray<number>,\n          c: $ReadOnlyMap<string, number>,\n          b: Map<string, Array<Map<string, number>>>,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          ...ErrorsInRecursiveGenericTypeArgsButDoesNotFix<{\n            y: boolean,\n            x: string,\n            z: {\n              j: string,\n              l: number,\n              k: boolean,\n            },\n          }>,\n          a: number,\n          c: string,\n          b: Map<string, Array<ErrorsInRecursiveGenericTypeArgsButDoesNotFix<{\n            y: boolean,\n            x: string,\n            z: {\n              j: string,\n              l: number,\n              k: boolean,\n            },\n          }>>>,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"x\" must be before \"y\".\n// Message: Expected type annotations to be in ascending order. \"k\" must be before \"l\".\n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n// Message: Expected type annotations to be in ascending order. \"x\" must be before \"y\".\n// Message: Expected type annotations to be in ascending order. \"k\" must be before \"l\".\n\n\n        type FooType = {\n          ...BPreservesSpreadOrder,\n          ...APreservesSpreadOrder,\n          c: string,\n          b: number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          ...BPreservesSpreadSpans,\n          ...APreservesSpreadSpans,\n          c: string,\n          b: number,\n          ...CPreservesSpreadSpans,\n          e: string,\n          d: number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n// Message: Expected type annotations to be in ascending order. \"d\" must be before \"e\".\n\n\n        type FooType = {\n          ...BPreservesSpreadOrderAndTypeArgs<string, number>,\n          ...APreservesSpreadOrderAndTypeArgs<number>,\n          c: string,\n          b: number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          /* preserves block comment before spread BType */\n          // preserves line comment before spread BType\n          ... /* preserves comment in spread BType */ BType<Generic> /* preserves trailing comment in spread AType */,\n          /* preserves block comment before spread AType */\n          // preserves line comment before spread AType\n          ... /* preserves comment in spread AType */ AType /* preserves trailing comment in spread AType */,\n          /* preserves block comment before reordered key \"c\" */\n          // preserves line comment before reordered key \"c\"\n          c:/* preserves comment and white space or lack of it */string/* preserves trailing comment for key \"c\" */,\n          b: number,\n          dWithoutComma: boolean\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          +a: number,\n          c: number,\n          b: string,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          -a: number,\n          c: number,\n          b: string,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          a?: number,\n          c: ?number,\n          b: string,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          a: (number) => void,\n          c: number,\n          b: (param: string) => number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          a: number | string | boolean,\n          c: number,\n          b: (param: string) => number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          c: number,\n          a: number | string | boolean,\n          b: (param: string) => number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"a\" must be before \"c\".\n\n\n        type FooType = {\n          c: {\n            z: number,\n            x: string,\n            y: boolean,\n          },\n          a: number | string | boolean,\n          b: (param: string) => number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"x\" must be before \"z\".\n// Message: Expected type annotations to be in ascending order. \"a\" must be before \"c\".\n\n\n        type FooType = {\n          c: {\n            z: {\n              j: string,\n              l: number,\n              k: boolean,\n            },\n            x: string,\n            y: boolean,\n          },\n          a: number | string | boolean,\n          b: (param: string) => number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"k\" must be before \"l\".\n// Message: Expected type annotations to be in ascending order. \"x\" must be before \"z\".\n// Message: Expected type annotations to be in ascending order. \"a\" must be before \"c\".\n\n\n        type FooType = {\n          +c: number,\n          -b: number,\n          a: number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n// Message: Expected type annotations to be in ascending order. \"a\" must be before \"b\".\n\n\n        type FooType = {|\n          +c: number,\n          -b: number,\n          a: number,\n        |}\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n// Message: Expected type annotations to be in ascending order. \"a\" must be before \"b\".\n\n\n        type FooType = {\n          a(number): void,\n          c: number,\n          b(param: string): number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          a: number | string | boolean,\n          c: number,\n          b(param: string): number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        type FooType = {\n          c: number,\n          a: number | string | boolean,\n          b(param: string): number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"a\" must be before \"c\".\n\n\n        type FooType = {\n          c: {\n            z: number,\n            x: string,\n            y: boolean,\n          },\n          a: number | string | boolean,\n          b(param: string): number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"x\" must be before \"z\".\n// Message: Expected type annotations to be in ascending order. \"a\" must be before \"c\".\n\n\n        type FooType = {\n          c: {\n            z: {\n              j: string,\n              l: number,\n              k: boolean,\n            },\n            x: string,\n            y: boolean,\n          },\n          a: number | string | boolean,\n          b(param: string): number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"k\" must be before \"l\".\n// Message: Expected type annotations to be in ascending order. \"x\" must be before \"z\".\n// Message: Expected type annotations to be in ascending order. \"a\" must be before \"c\".\n\n\n        type FooType = {\n          /* preserves block comment before a */\n          a: number | string | boolean,\n          /* preserves block comment before c */\n          c: number,\n          /* preserves block comment before b */\n          b(param: string): number,\n        }\n      \n// Message: Expected type annotations to be in ascending order. \"b\" must be before \"c\".\n\n\n        export type GroupOrdersResponseType = {|\n          isSuccess: boolean,\n          code: number,\n          message?: string,\n          errorMessage: string,\n          result: {|\n            OrderNumber: string,\n            Orders: GroupOrderSummaryType[],\n            PlacedOn: string,\n            Status: string,\n            ReturnText: string,\n            IncludesLegacyOrder: boolean\n          |}\n        |};\n      \n// Message: Expected type annotations to be in ascending order. \"code\" must be before \"isSuccess\".\n// Message: Expected type annotations to be in ascending order. \"errorMessage\" must be before \"message\".\n// Message: Expected type annotations to be in ascending order. \"ReturnText\" must be before \"Status\".\n// Message: Expected type annotations to be in ascending order. \"IncludesLegacyOrder\" must be before \"ReturnText\".\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype FooType = { a: number }\n\ntype FooType = { a: number, b: number, c: (boolean | number) }\n\ntype FooType = { a: string, b: foo, C: number }\n\ntype FooType = { 1: number, 2: boolean, 10: number }\n\n// Options: [\"desc\"]\ntype FooType = { c: number, b: number, a: number }\n\n// Options: [\"desc\"]\ntype FooType = { C: number, b: string, a: {} }\n\n// Options: [\"desc\"]\ntype FooType = { 10: number, 2: number, 1: boolean }\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype FooType = { b: number, a: number }\n\ntype FooType = { a: string, b(): number, c: boolean }\n\ntype FooType = { a(): string, b: number, c: boolean }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-sort-type-union-intersection-members\"></a>\n### <code>sort-type-union-intersection-members</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces that members of a type union/intersection are sorted alphabetically.\n\n<a name=\"eslint-plugin-flowtype-rules-sort-type-union-intersection-members-options-16\"></a>\n#### Options\n\nYou can specify the sort order using `order`.\n\n* `\"asc\"` (default) - enforce ascending sort order.\n* `\"desc\"` - enforce descending sort order.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/sort-type-union-intersection-members\": [\n      2,\n      {\n        \"order\": \"asc\"\n      }\n    ]\n  }\n}\n```\n\nYou can disable checking intersection types using `checkIntersections`.\n\n* `true` (default) - enforce sort order of intersection members.\n* `false` - do not enforce sort order of intersection members.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/sort-type-union-intersection-members\": [\n      2,\n      {\n        \"checkIntersections\": true\n      }\n    ]\n  }\n}\n```\n\nYou can disable checking union types using `checkUnions`.\n\n* `true` (default) - enforce sort order of union members.\n* `false` - do not enforce sort order of union members.\n\n```js\n{\n  \"rules\": {\n    \"flowtype/sort-type-union-intersection-members\": [\n      2,\n      {\n        \"checkUnions\": true\n      }\n    ]\n  }\n}\n```\n\nYou can specify the ordering of groups using `groupOrder`.\n\nEach member of the type is placed into a group, and then the rule sorts alphabetically within each group.\nThe ordering of groups is determined by this option.\n\n* `keyword` - Keyword types (`any`, `string`, etc)\n* `named` - Named types (`A`, `A['prop']`, `B[]`, `Array<C>`)\n* `literal` - Literal types (`1`, `'b'`, `true`, etc)\n* `function` - Function types (`() => void`)\n* `object` - Object types (`{ a: string }`, `{ [key: string]: number }`)\n* `tuple` - Tuple types (`[A, B, C]`)\n* `intersection` - Intersection types (`A & B`)\n* `union` - Union types (`A | B`)\n* `nullish` - `null` and `undefined`\n\n```js\n{\n  \"rules\": {\n    \"flowtype/sort-type-union-intersection-members\": [\n      2,\n      {\n        \"groupOrder\": [\n          'keyword',\n          'named',\n          'literal',\n          'function',\n          'object',\n          'tuple',\n          'intersection',\n          'union',\n          'nullish',\n        ]\n      }\n    ]\n  }\n}\n```\n\nThe following patterns are considered problems:\n\n```js\ntype T1 = B | A;\n// Message: Expected union members to be in ascending order. \"A\" should be before \"B\".\n\ntype T2 = { b: string } & { a: string };\n// Message: Expected intersection members to be in ascending order. \"{ a: string }\" should be before \"{ b: string }\".\n\ntype T3 = [1, 2, 4] & [1, 2, 3];\n// Message: Expected intersection members to be in ascending order. \"[1, 2, 3]\" should be before \"[1, 2, 4]\".\n\n\n        type T4 =\n          | [1, 2, 4]\n          | [1, 2, 3]\n          | { b: string }\n          | { a: string }\n          | (() => void)\n          | (() => string)\n          | 'b'\n          | 'a'\n          | 'b'\n          | 'a'\n          | string[]\n          | number[]\n          | B\n          | A\n          | string\n          | any;\n      \n// Message: Expected union members to be in ascending order. \"[1, 2, 3]\" should be before \"[1, 2, 4]\".\n// Message: Expected union members to be in ascending order. \"{ b: string }\" should be before \"[1, 2, 3]\".\n// Message: Expected union members to be in ascending order. \"{ a: string }\" should be before \"{ b: string }\".\n// Message: Expected union members to be in ascending order. \"() => void\" should be before \"{ a: string }\".\n// Message: Expected union members to be in ascending order. \"() => string\" should be before \"() => void\".\n// Message: Expected union members to be in ascending order. \"'b'\" should be before \"() => string\".\n// Message: Expected union members to be in ascending order. \"'a'\" should be before \"'b'\".\n// Message: Expected union members to be in ascending order. \"'b'\" should be before \"'a'\".\n// Message: Expected union members to be in ascending order. \"'a'\" should be before \"'b'\".\n// Message: Expected union members to be in ascending order. \"string[]\" should be before \"'a'\".\n// Message: Expected union members to be in ascending order. \"number[]\" should be before \"string[]\".\n// Message: Expected union members to be in ascending order. \"B\" should be before \"number[]\".\n// Message: Expected union members to be in ascending order. \"A\" should be before \"B\".\n// Message: Expected union members to be in ascending order. \"string\" should be before \"A\".\n// Message: Expected union members to be in ascending order. \"any\" should be before \"string\".\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype T1 = A | B;\n\ntype T2 = { a: string } & { b: string };\n\ntype T3 = [1, 2, 3] & [1, 2, 4];\n\n\n        type T4 =\n          | any\n          | string\n          | A\n          | B\n          | number[]\n          | string[]\n          | 'a'\n          | 'a'\n          | 'b'\n          | 'b'\n          | (() => string)\n          | (() => void)\n          | { a: string }\n          | { b: string }\n          | [1, 2, 3]\n          | [1, 2, 4];\n      \n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-space-after-type-colon\"></a>\n### <code>space-after-type-colon</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing after the type annotation colon.\n\n<a name=\"eslint-plugin-flowtype-rules-space-after-type-colon-options-17\"></a>\n#### Options\n\nThis rule has a string argument.\n\n* `\"always\"` (default): Require a space after the type annotation colon (e.g. foo: BarType).\n* `\"never\"`: Require no spaces after the type annotation colon (e.g. foo:BarType).\n\nThis rule has an option object.\n\n* `\"allowLineBreak\"` - Allow a line break to count as a space following the annotation colon.\n    * `\"true\"`: Enable\n    * `\"false\"`: Disable\n\n{\n  \"rules\": {\n    \"flowtype/space-after-type-colon\": [\n      2,\n      \"always\", {\n        \"allowLineBreak\": false\n      }\n    ]\n  }\n}\n\nThe following patterns are considered problems:\n\n```js\n// Options: [\"never\"]\n(foo: string) => {}\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo:  string) => {}\n// Message: There must be 1 space after \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo:(() => void)) => {}\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\n(foo: (() => void)) => {}\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo:  (() => void)) => {}\n// Message: There must be 1 space after \"foo\" parameter type annotation colon.\n\n({ lorem, ipsum, dolor } :   SomeType) => {}\n// Message: There must be 1 space after \"{ lorem, ipsum, dolor }\" parameter type annotation colon.\n\n(foo:{ a: string, b: number }) => {}\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\n({ a, b } :{ a: string, b: number }) => {}\n// Message: There must be a space after \"{ a, b }\" parameter type annotation colon.\n\n([ a, b ] :string[]) => {}\n// Message: There must be a space after \"[ a, b ]\" parameter type annotation colon.\n\n(i?:number) => {}\n// Message: There must be a space after \"i\" parameter type annotation colon.\n\n(i?:  number) => {}\n// Message: There must be 1 space after \"i\" parameter type annotation colon.\n\n// Options: [\"never\"]\n(i?: number) => {}\n// Message: There must be no space after \"i\" parameter type annotation colon.\n\n(foo:\n  { a: string, b: number }) => {}\n// Message: There must not be a line break after \"foo\" parameter type annotation colon.\n\n(foo:\n{ a: string, b: number }) => {}\n// Message: There must not be a line break after \"foo\" parameter type annotation colon.\n\n(foo: \n{ a: string, b: number }) => {}\n// Message: There must not be a line break after \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n():Object => {}\n// Message: There must be a space after return type colon.\n\n// Options: [\"never\"]\n(): Object => {}\n// Message: There must be no space after return type colon.\n\n// Options: [\"always\"]\n():  Object => {}\n// Message: There must be 1 space after return type colon.\n\n// Options: [\"always\"]\n():(() => void) => {}\n// Message: There must be a space after return type colon.\n\n// Options: [\"never\"]\n(): (() => void) => {}\n// Message: There must be no space after return type colon.\n\n// Options: [\"always\"]\n():  (() => void) => {}\n// Message: There must be 1 space after return type colon.\n\n// Options: [\"never\"]\nexport default function (foo: string) {}\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\nfunction foo (foo: string) {}\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo:string) => {}\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\nfunction foo (foo:string) {}\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\nasync function foo({ lorem, ipsum, dolor }:SomeType) {}\n// Message: There must be a space after \"{ lorem, ipsum, dolor }\" parameter type annotation colon.\n\nfunction x(i?:number) {}\n// Message: There must be a space after \"i\" parameter type annotation colon.\n\nfunction x(i?:  number) {}\n// Message: There must be 1 space after \"i\" parameter type annotation colon.\n\n// Options: [\"never\"]\nfunction x(i?: number) {}\n// Message: There must be no space after \"i\" parameter type annotation colon.\n\nfunction a():x {}\n// Message: There must be a space after return type colon.\n\n// Options: [\"always\"]\nfunction a():  x {}\n// Message: There must be 1 space after return type colon.\n\n// Options: [\"never\"]\nfunction a(): x {}\n// Message: There must be no space after return type colon.\n\ntype X = (foo:number) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\ntype X = (foo: number) => string\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:  number) => string\n// Message: There must be 1 space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:?number) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:(number)) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:((number))) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:  ((number))) => string\n// Message: There must be 1 space after \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\ntype X = (foo: ((number))) => string\n// Message: There must be no space after \"foo\" parameter type annotation colon.\n\ntype X = (foo:?(number)) => string\n// Message: There must be a space after \"foo\" parameter type annotation colon.\n\ntype TArrayPredicate = (el: T, i?:number) => boolean\n// Message: There must be a space after \"i\" parameter type annotation colon.\n\ntype TArrayPredicate = (el: T, i?:  number) => boolean\n// Message: There must be 1 space after \"i\" parameter type annotation colon.\n\n// Options: [\"never\"]\ntype TArrayPredicate = (el:T, i?: number) => boolean\n// Message: There must be no space after \"i\" parameter type annotation colon.\n\nclass X { foo:string }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { foo: string }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\nclass X { foo:?string }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { foo: ?string }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\nclass X { static foo:number }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { static foo: number }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\nclass X { static foo :number }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { static foo : number }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\ndeclare class X { static foo:number }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ndeclare class X { static foo: number }\n// Message: There must be no space after \"foo\" type annotation colon.\n\ndeclare class X { static foo :number }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ndeclare class X { static foo : number }\n// Message: There must be no space after \"foo\" type annotation colon.\n\nclass X { +foo:string }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\nclass X { +foo:  string }\n// Message: There must be 1 space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { +foo: string }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\nclass X { static +foo:string }\n// Message: There must be a space after \"foo\" class property type annotation colon.\n\nclass X { static +foo:  string }\n// Message: There must be 1 space after \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { static +foo: string }\n// Message: There must be no space after \"foo\" class property type annotation colon.\n\ntype X = { foo:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { foo: string }\n// Message: There must be no space after \"foo\" type annotation colon.\n\ntype X = { foo:  string }\n// Message: There must be 1 space after \"foo\" type annotation colon.\n\ntype X = { foo?:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { foo?: string }\n// Message: There must be no space after \"foo\" type annotation colon.\n\ntype X = { foo?:?string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\ntype X = { foo?:  ?string }\n// Message: There must be 1 space after \"foo\" type annotation colon.\n\ntype Foo = { barType:(string | () => void) }\n// Message: There must be a space after \"barType\" type annotation colon.\n\ntype Foo = { barType:(((string | () => void))) }\n// Message: There must be a space after \"barType\" type annotation colon.\n\n// Options: [\"never\"]\ntype Foo = { barType: (string | () => void) }\n// Message: There must be no space after \"barType\" type annotation colon.\n\ntype Foo = { barType:  (string | () => void) }\n// Message: There must be 1 space after \"barType\" type annotation colon.\n\ntype Foo = { barType:  ((string | () => void)) }\n// Message: There must be 1 space after \"barType\" type annotation colon.\n\ntype X = { get:() => A; }\n// Message: There must be a space after \"get\" type annotation colon.\n\ntype X = { get:<X>() => A; }\n// Message: There must be a space after \"get\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { get: () => A; }\n// Message: There must be no space after \"get\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { get: <X>() => A; }\n// Message: There must be no space after \"get\" type annotation colon.\n\ntype X = { get:  () => A; }\n// Message: There must be 1 space after \"get\" type annotation colon.\n\ntype X = { get:  <X>() => A; }\n// Message: There must be 1 space after \"get\" type annotation colon.\n\ntype X = { +foo:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\ntype X = { +foo:  string }\n// Message: There must be 1 space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +foo: string }\n// Message: There must be no space after \"foo\" type annotation colon.\n\ntype X = { +foo?:string }\n// Message: There must be a space after \"foo\" type annotation colon.\n\ntype X = { +foo?:  string }\n// Message: There must be 1 space after \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +foo?: string }\n// Message: There must be no space after \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a:b]: c }\n// Message: There must be a space after type annotation colon.\n\n// Options: [\"never\"]\ntype X = { [a: b]:c }\n// Message: There must be no space after type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a:    b]: c }\n// Message: There must be 1 space after type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +[a:b]: c }\n// Message: There must be a space after type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +[a: b]:c }\n// Message: There must be no space after type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +[a:    b]: c }\n// Message: There must be 1 space after type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a: b]:c }\n// Message: There must be a space after type annotation colon.\n\n// Options: [\"never\"]\ntype X = { [a:b]: c }\n// Message: There must be no space after type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a: b]:    c }\n// Message: There must be 1 space after type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a:b]:c }\n// Message: There must be a space after type annotation colon.\n// Message: There must be a space after type annotation colon.\n\n// Options: [\"never\"]\ntype X = { [a: b]: c }\n// Message: There must be no space after type annotation colon.\n// Message: There must be no space after type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a:  b]:  c }\n// Message: There must be 1 space after type annotation colon.\n// Message: There must be 1 space after type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a:(b)]:(c) }\n// Message: There must be a space after type annotation colon.\n// Message: There must be a space after type annotation colon.\n\n// Options: [\"never\"]\ntype X = { [a: (b)]: (c) }\n// Message: There must be no space after type annotation colon.\n// Message: There must be no space after type annotation colon.\n\n// Options: [\"never\"]\nconst x = ({}: {})\n// Message: There must be no space after type cast colon.\n\n// Options: [\"always\"]\nconst x = ({}:{})\n// Message: There must be a space after type cast colon.\n\n// Options: [\"always\"]\nconst x = ({}:  {})\n// Message: There must be 1 space after type cast colon.\n\n// Options: [\"never\"]\n((x): (string))\n// Message: There must be no space after type cast colon.\n\n// Options: [\"always\"]\n((x):(string))\n// Message: There must be a space after type cast colon.\n\n// Options: [\"always\"]\n((x):  (string))\n// Message: There must be 1 space after type cast colon.\n\n// Options: [\"always\"]\nconst x:number = 7;\n// Message: There must be a space after const type annotation colon.\n\n// Options: [\"always\"]\nlet x:number = 42;\n// Message: There must be a space after let type annotation colon.\n\n// Options: [\"always\"]\nvar x:number = 42;\n// Message: There must be a space after var type annotation colon.\n```\n\nThe following patterns are not considered problems:\n\n```js\n(foo) => {}\n\n(foo: string) => {}\n\n(foo: (string|number)) => {}\n\n// Options: [\"never\"]\n(foo:string) => {}\n\n// Options: [\"always\"]\n(foo: string) => {}\n\n// Options: [\"never\"]\n(foo:(() => void)) => {}\n\n// Options: [\"always\"]\n(foo: (() => void)) => {}\n\n({ lorem, ipsum, dolor }: SomeType) => {}\n\n(foo: { a: string, b: number }) => {}\n\n({ a, b }: ?{ a: string, b: number }) => {}\n\n([ a, b ]: string[]) => {}\n\n(i?: number) => {}\n\n// Options: [\"never\"]\n(i?:number) => {}\n\n// Options: [\"always\",{\"allowLineBreak\":true}]\n(foo:\n  { a: string, b: number }) => {}\n\n// Options: [\"always\",{\"allowLineBreak\":true}]\n(foo:\n  { a: string, b: number }) => {}\n\n// Options: [\"never\"]\n():Object => {}\n\n// Options: [\"always\"]\n(): Object => {}\n\n// Options: [\"never\"]\n():(number | string) => {}\n\n// Options: [\"always\"]\n(): (number | string) => {}\n\n// Options: [\"never\"]\n():number|string => {}\n\n// Options: [\"always\"]\n(): number|string => {}\n\n// Options: [\"never\"]\n():(() => void) => {}\n\n// Options: [\"always\"]\n(): (() => void) => {}\n\n// Options: [\"never\"]\n():( () => void ) => {}\n\n// Options: [\"always\"]\n(): ( () => void ) => {}\n\n(): { a: number, b: string } => {}\n\n// Options: [\"never\"]\n() :{ a:number, b:string } => {}\n\nfunction x(foo: string) {}\n\nclass Foo { constructor(foo: string) {} }\n\n// Options: [\"never\"]\nfunction x(foo:string) {}\n\n// Options: [\"never\"]\nclass Foo { constructor(foo:string) {} }\n\nasync function foo({ lorem, ipsum, dolor }: SomeType) {}\n\nfunction x({ a, b }: { a: string, b: number }) {}\n\nfunction x(i?: number) {}\n\n// Options: [\"never\"]\nfunction x(i?:number) {}\n\nfunction a(): x {}\n\n// Options: [\"never\"]\nfunction a():x {}\n\nfunction a(): (number | string) {}\n\n// Options: [\"never\"]\nfunction a() :(number | string) {}\n\ntype X = (foo: number) => string;\n\ntype X = (foo : number) => string;\n\ntype X = (foo: ?number) => string;\n\ntype X = (foo? : ?number) => string;\n\ntype X = (foo: ?{ x: number }) => string;\n\n// Options: [\"never\"]\ntype X = (foo:number) => string;\n\n// Options: [\"never\"]\ntype X = (foo:?{ x:number }) => string;\n\ntype X = (foo: (number)) => string\n\ntype X = (foo: ((number))) => string\n\n// Options: [\"never\"]\ntype X = (foo:((number))) => string\n\ntype X = ?(foo: ((number))) => string\n\n// Options: [\"never\"]\ntype X = ?(foo:((number))) => string\n\ntype TArrayPredicate = (el: T, i?: number) => boolean\n\n// Options: [\"never\"]\ntype TArrayPredicate = (el:T, i?:number) => boolean\n\ntype X = (number) => string;\n\ntype X = (?number) => string;\n\ntype X = number => string;\n\ntype X = ?number => string;\n\ntype X = ({ foo: bar }) => string;\n\n// Options: [\"always\"]\ntype X = (number) => string;\n\n// Options: [\"always\"]\ntype X = (?number) => string;\n\n// Options: [\"always\"]\ntype X = number => string;\n\n// Options: [\"always\"]\ntype X = ?number => string;\n\n// Options: [\"always\"]\ntype X = ({ foo: bar }) => string;\n\nclass Foo { bar }\n\nclass Foo { bar = 3 }\n\nclass Foo { bar: string }\n\nclass Foo { bar: ?string }\n\n// Options: [\"never\"]\nclass Foo { bar:string }\n\n// Options: [\"never\"]\nclass Foo { bar:?string }\n\nclass X { static foo : number }\n\n// Options: [\"never\"]\nclass X { static foo :number }\n\ndeclare class X { static foo : number }\n\n// Options: [\"never\"]\ndeclare class X { static foo :number }\n\nclass X { +foo: string }\n\nclass X { static +foo: string }\n\n// Options: [\"never\"]\nclass X { +foo:string }\n\n// Options: [\"never\"]\nclass X { static +foo:string }\n\ntype X = { foo: string }\n\n// Options: [\"never\"]\ntype X = { foo:string }\n\ntype X = { foo?: string }\n\ntype X = { foo?: ?string }\n\n// Options: [\"never\"]\ntype X = { foo?:?string }\n\ntype Foo = { barType: (string | () => void) }\n\ntype Foo = { barType: ((string | () => void)) }\n\n// Options: [\"never\"]\ntype Foo = { barType:(string | () => void) }\n\n// Options: [\"never\"]\ntype Foo = { barType:((string | () => void)) }\n\ntype X = { get(): A; }\n\ntype X = { get<X>(): A; }\n\n// Options: [\"never\"]\ntype X = { get(): A; }\n\n// Options: [\"never\"]\ntype X = { get<X>(): A; }\n\ntype X = { get: () => A; }\n\ntype X = { get: <X>() => A; }\n\n// Options: [\"never\"]\ntype X = { get:() => A; }\n\n// Options: [\"never\"]\ntype X = { get:<X>() => A; }\n\ntype X = { +foo: string }\n\ntype X = { +foo?: string }\n\n// Options: [\"never\"]\ntype X = { +foo:string }\n\n// Options: [\"never\"]\ntype X = { +foo?:string }\n\n// Options: [\"always\"]\ntype X = { [a: b]: c }\n\n// Options: [\"never\"]\ntype X = { [a:b]:c }\n\n// Options: [\"always\"]\ntype X = { +[a: b]: c }\n\n// Options: [\"never\"]\ntype X = { +[a:b]:c }\n\n// Options: [\"always\"]\ntype X = { [string]: c }\n\n// Options: [\"never\"]\ntype X = { [string]:c }\n\n// Options: [\"never\"]\nconst x = ({}:{})\n\n// Options: [\"always\"]\nconst x = ({}: {})\n\n// Options: [\"never\"]\n((x):(string))\n\n// Options: [\"always\"]\n((x): (string))\n\n// Options: [\"always\"]\nconst x: number = 7;\n\n// Options: [\"always\"]\nlet x: number = 42;\n\n// Options: [\"always\"]\nvar x: number = 42;\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-space-before-generic-bracket\"></a>\n### <code>space-before-generic-bracket</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing before the opening `<` of generic type annotation parameters.\n\nThis rule takes one argument. If it is `'never'` then a problem is raised when there is a space before the `<`. If it is `'always'` then a problem is raised when there is no space before the `<`.\n\nThe default value is `'never'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = Promise <string>\n// Message: There must be no space before \"Promise\" generic type annotation bracket\n\n// Options: [\"never\"]\ntype X = Promise <string>\n// Message: There must be no space before \"Promise\" generic type annotation bracket\n\ntype X = Promise  <string>\n// Message: There must be no space before \"Promise\" generic type annotation bracket\n\n// Options: [\"always\"]\ntype X = Promise<string>\n// Message: There must be a space before \"Promise\" generic type annotation bracket\n\n// Options: [\"always\"]\ntype X = Promise  <string>\n// Message: There must be one space before \"Promise\" generic type annotation bracket\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = Promise<string>\n\n// Options: [\"always\"]\ntype X = Promise <string>\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-space-before-type-colon\"></a>\n### <code>space-before-type-colon</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing before the type annotation colon.\n\nThis rule takes one argument. If it is `'always'` then a problem is raised when there is no space before the type annotation colon. If it is `'never'` then a problem is raised when there is a space before the type annotation colon. The default value is `'never'`.\n\nThe following patterns are considered problems:\n\n```js\n// Options: [\"never\"]\n(foo : string) => {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"never\"]\n(foo ? : string) => {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo: string) => {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo  : string) => {}\n// Message: There must be 1 space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo?: string) => {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo ?  : string) => {}\n// Message: There must be 1 space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\n(foo  ?: string) => {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\n({ lorem, ipsum, dolor } : SomeType) => {}\n// Message: There must be no space before \"{ lorem, ipsum, dolor }\" parameter type annotation colon.\n\n(foo : { a: string, b: number }) => {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n({ a, b } : { a: string, b: number }) => {}\n// Message: There must be no space before \"{ a, b }\" parameter type annotation colon.\n\n([ a, b ] : string[]) => {}\n// Message: There must be no space before \"[ a, b ]\" parameter type annotation colon.\n\n() : x => {}\n// Message: There must be no space before return type colon.\n\n// Options: [\"always\"]\n(): x => {}\n// Message: There must be a space before return type colon.\n\n// Options: [\"always\"]\n()  : x => {}\n// Message: There must be 1 space before return type colon.\n\nfunction x(foo : string) {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\nfunction x(foo: string) {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\nvar x = function (foo : string) {}\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\nvar x = function (foo: string) {}\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\nclass Foo { constructor(foo : string ) {} }\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\nclass Foo { constructor(foo: string ) {} }\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\nasync function foo({ lorem, ipsum, dolor } : SomeType) {}\n// Message: There must be no space before \"{ lorem, ipsum, dolor }\" parameter type annotation colon.\n\nfunction a() : x {}\n// Message: There must be no space before return type colon.\n\n// Options: [\"always\"]\nfunction a(): x {}\n// Message: There must be a space before return type colon.\n\n// Options: [\"always\"]\nfunction a()  : x {}\n// Message: There must be 1 space before return type colon.\n\ntype X = (foo :string) => string;\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\ntype X = (foo:string) => string;\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\ntype X = (foo  :string) => string;\n// Message: There must be 1 space before \"foo\" parameter type annotation colon.\n\ntype X = (foo? :string) => string;\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\ntype X = (foo?     :string) => string;\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\n// Options: [\"always\"]\ntype X = (foo?:string) => string;\n// Message: There must be a space before \"foo\" parameter type annotation colon.\n\ntype X = (foo? :?string) => string;\n// Message: There must be no space before \"foo\" parameter type annotation colon.\n\nclass X { foo :string }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { foo: string }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\nclass X { foo :?string }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { foo: ?string }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\nclass X { static foo : number }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\nclass X { static foo :number }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { static foo: number }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { static foo:number }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\ndeclare class Foo { static bar :number; }\n// Message: There must be no space before \"bar\" type annotation colon.\n\ndeclare class Foo { static bar : number; }\n// Message: There must be no space before \"bar\" type annotation colon.\n\n// Options: [\"always\"]\ndeclare class Foo { static bar:number; }\n// Message: There must be a space before \"bar\" type annotation colon.\n\n// Options: [\"always\"]\ndeclare class Foo { static bar: number; }\n// Message: There must be a space before \"bar\" type annotation colon.\n\n// Options: [\"always\"]\nclass X { +foo: string }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { +foo  : string }\n// Message: There must be 1 space before \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { +foo : string }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { static +foo: string }\n// Message: There must be a space before \"foo\" class property type annotation colon.\n\n// Options: [\"always\"]\nclass X { static +foo  : string }\n// Message: There must be 1 space before \"foo\" class property type annotation colon.\n\n// Options: [\"never\"]\nclass X { static +foo : string }\n// Message: There must be no space before \"foo\" class property type annotation colon.\n\ntype X = { foo : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { foo : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo  : string }\n// Message: There must be 1 space before \"foo\" type annotation colon.\n\ntype X = { foo? : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo?: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo?  : string }\n// Message: There must be 1 space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { foo   ?: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +foo: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +foo  : string }\n// Message: There must be 1 space before \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +foo : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +foo?: string }\n// Message: There must be a space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +foo?  : string }\n// Message: There must be 1 space before \"foo\" type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +foo? : string }\n// Message: There must be no space before \"foo\" type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a: b] : c }\n// Message: There must be a space before type annotation colon.\n\n// Options: [\"never\"]\ntype X = { [a : b]: c }\n// Message: There must be no space before type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a  : b] : c }\n// Message: There must be 1 space before type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +[a:b] : c }\n// Message: There must be a space before type annotation colon.\n\n// Options: [\"never\"]\ntype X = { +[a : b]: c }\n// Message: There must be no space before type annotation colon.\n\n// Options: [\"always\"]\ntype X = { +[a  : b] : c }\n// Message: There must be 1 space before type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a : b]: c }\n// Message: There must be a space before type annotation colon.\n\n// Options: [\"never\"]\ntype X = { [a: b] : c }\n// Message: There must be no space before type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a : b]  : c }\n// Message: There must be 1 space before type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a:b]:c }\n// Message: There must be a space before type annotation colon.\n// Message: There must be a space before type annotation colon.\n\n// Options: [\"never\"]\ntype X = { [a : b] : c }\n// Message: There must be no space before type annotation colon.\n// Message: There must be no space before type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a  : b]  : c }\n// Message: There must be 1 space before type annotation colon.\n// Message: There must be 1 space before type annotation colon.\n\n// Options: [\"always\"]\ntype X = { [a:(b)]:(c) }\n// Message: There must be a space before type annotation colon.\n// Message: There must be a space before type annotation colon.\n\n// Options: [\"never\"]\ntype X = { [a : (b)] : (c) }\n// Message: There must be no space before type annotation colon.\n// Message: There must be no space before type annotation colon.\n\n// Options: [\"never\"]\nconst x = ({} :{})\n// Message: There must be no space before type cast colon.\n\n// Options: [\"always\"]\nconst x = ({}:{})\n// Message: There must be a space before type cast colon.\n\n// Options: [\"always\"]\nconst x = ({}  :{})\n// Message: There must be 1 space before type cast colon.\n\n// Options: [\"never\"]\n((x) : string)\n// Message: There must be no space before type cast colon.\n\n// Options: [\"always\"]\n((x): string)\n// Message: There must be a space before type cast colon.\n\n// Options: [\"always\"]\n((x)  : string)\n// Message: There must be 1 space before type cast colon.\n\n// Options: [\"always\"]\nconst x:number = 7;\n// Message: There must be a space before const type annotation colon.\n\n// Options: [\"always\"]\nlet x:number = 42;\n// Message: There must be a space before let type annotation colon.\n\n// Options: [\"always\"]\nvar x:number = 42;\n// Message: There must be a space before var type annotation colon.\n```\n\nThe following patterns are not considered problems:\n\n```js\n(foo) => {}\n\n(foo: string) => {}\n\n(foo?: string) => {}\n\n(foo ?: string) => {}\n\n// Options: [\"never\"]\n(foo: string) => {}\n\n// Options: [\"always\"]\n(foo : string) => {}\n\n// Options: [\"always\"]\n(foo? : string) => {}\n\n// Options: [\"always\"]\n(foo ? : string) => {}\n\n// Options: [\"always\"]\n(foo  ? : string) => {}\n\n({ lorem, ipsum, dolor }: SomeType) => {}\n\n(foo: { a: string, b: number }) => {}\n\n({ a, b }: ?{ a: string, b: number }) => {}\n\n(): { a: number, b: string } => {}\n\n// Options: [\"always\"]\n() : { a : number, b : string } => {}\n\n([ a, b ]: string[]) => {}\n\n(): x => {}\n\n// Options: [\"always\"]\n() : x => {}\n\n(): (number | string) => {}\n\n// Options: [\"always\"]\n() : (number | string) => {}\n\nfunction x(foo: string) {}\n\n// Options: [\"always\"]\nfunction x(foo : string) {}\n\nvar x = function (foo: string) {}\n\n// Options: [\"always\"]\nvar x = function (foo : string) {}\n\nclass X { foo({ bar }: Props = this.props) {} }\n\nclass Foo { constructor(foo: string ) {} }\n\n// Options: [\"always\"]\nclass Foo { constructor(foo : string ) {} }\n\nasync function foo({ lorem, ipsum, dolor }: SomeType) {}\n\nfunction x({ a, b }: { a: string, b: number }) {}\n\nfunction a(): x {}\n\n// Options: [\"always\"]\nfunction a() : x {}\n\nfunction a(): (number | string) {}\n\n// Options: [\"always\"]\nfunction a() : (number | string) {}\n\ntype X = (foo:string) => number;\n\ntype X = (foo: string) => number;\n\ntype X = (foo: ?string) => number;\n\ntype X = (foo?: string) => number;\n\ntype X = (foo?: ?string) => number;\n\ntype X = (foo   ?: string) => number;\n\n// Options: [\"always\"]\ntype X = (foo? : string) => number\n\n// Options: [\"always\"]\ntype X = (foo? : ?string) => number\n\ntype X = (number) => string;\n\ntype X = (?number) => string;\n\ntype X = number => string;\n\ntype X = ?number => string;\n\ntype X = ({ foo: bar }) => string;\n\n// Options: [\"always\"]\ntype X = (number) => string;\n\n// Options: [\"always\"]\ntype X = (?number) => string;\n\n// Options: [\"always\"]\ntype X = number => string;\n\n// Options: [\"always\"]\ntype X = ?number => string;\n\n// Options: [\"always\"]\ntype X = ({ foo : bar }) => string;\n\nclass Foo { bar }\n\nclass Foo { bar = 3 }\n\nclass Foo { bar: string }\n\nclass Foo { bar: ?string }\n\nclass Foo { bar:?string }\n\n// Options: [\"always\"]\nclass Foo { bar : string }\n\nclass X { static foo:number }\n\nclass X { static foo: number }\n\n// Options: [\"always\"]\nclass X { static foo :number }\n\n// Options: [\"always\"]\nclass X { static foo : number }\n\ndeclare class Foo { static bar:number; }\n\n// Options: [\"always\"]\ndeclare class Foo { static bar :number; }\n\ndeclare class Foo { static bar: number; }\n\n// Options: [\"always\"]\ndeclare class Foo { static bar : number; }\n\nclass X { +foo: string }\n\nclass X { static +foo: string }\n\n// Options: [\"always\"]\nclass X { +foo : string }\n\n// Options: [\"always\"]\nclass X { static +foo : string }\n\ntype X = { foo: string }\n\n// Options: [\"always\"]\ntype X = { foo : string }\n\ntype X = { foo?: string }\n\ntype X = { foo   ?: string }\n\n// Options: [\"always\"]\ntype X = { foo? : string }\n\ntype X = { +foo: string }\n\ntype X = { +foo?: string }\n\n// Options: [\"always\"]\ntype X = { +foo : string }\n\n// Options: [\"always\"]\ntype X = { +foo? : string }\n\n// Options: [\"always\"]\ntype X = { [a : b] : c }\n\n// Options: [\"never\"]\ntype X = { [a:b]:c }\n\n// Options: [\"always\"]\ntype X = { [string] : c }\n\n// Options: [\"never\"]\ntype X = { [string]:c }\n\n// Options: [\"always\"]\ntype X = { +[a : b] : c }\n\n// Options: [\"never\"]\ntype X = { +[a:b]:c }\n\n// Options: [\"always\"]\ntype X = { [a : (b)] : (c) }\n\n// Options: [\"never\"]\ntype X = { [a:(b)]:(c) }\n\n// Options: [\"never\"]\nconst x = ({}:{})\n\n// Options: [\"always\"]\nconst x = ({} :{})\n\n// Options: [\"never\"]\n((x): string)\n\n// Options: [\"always\"]\n((x) : string)\n\n// Options: [\"always\"]\nconst x :number = 7;\n\n// Options: [\"always\"]\nlet x :number = 42;\n\n// Options: [\"always\"]\nvar x :number = 42;\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-spread-exact-type\"></a>\n### <code>spread-exact-type</code>\n\nEnforce object types, that are spread to be exact type explicitly.\n\nThe following patterns are considered problems:\n\n```js\ntype bar = {...{test: string}}\n// Message: Use $Exact to make type spreading safe.\n\ntype foo = {test: number}; type bar = {...foo}\n// Message: Use $Exact to make type spreading safe.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype bar = {...$Exact<{test: string}>}\n\ntype foo = {test: number}; type bar = {...$Exact<foo>}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-type-id-match\"></a>\n### <code>type-id-match</code>\n\nEnforces a consistent naming pattern for type aliases.\n\n<a name=\"eslint-plugin-flowtype-rules-type-id-match-options-18\"></a>\n#### Options\n\nThis rule requires a text RegExp:\n\n```js\n{\n    \"rules\": {\n        \"flowtype/type-id-match\": [\n            2,\n            \"^([A-Z][a-z0-9]*)+Type$\"\n        ]\n    }\n}\n```\n\n`'^([A-Z][a-z0-9]*)+Type$$'` is the default pattern.\n\nThe following patterns are considered problems:\n\n```js\nopaque type foo = {};\n// Message: Type identifier 'foo' does not match pattern '/^([A-Z][a-z0-9]*)+Type$/u'.\n\ntype foo = {};\n// Message: Type identifier 'foo' does not match pattern '/^([A-Z][a-z0-9]*)+Type$/u'.\n\n// Options: [\"^foo$\"]\ntype FooType = {};\n// Message: Type identifier 'FooType' does not match pattern '/^foo$/u'.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype FooType = {};\n\n// Options: [\"^foo$\"]\ntype foo = {};\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype foo = {};\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-type-import-style\"></a>\n### <code>type-import-style</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces a particular style for type imports:\n\n```\n// 'identifier' style\nimport {type T, type U, type V} from '...';\n\n// 'declaration' style\nimport type {T, U, V} from '...';\n```\n\n<a name=\"eslint-plugin-flowtype-rules-type-import-style-options-19\"></a>\n#### Options\n\nThe rule has a string option:\n\n* `\"identifier\"` (default): Enforces that type imports are all in the\n  'identifier' style.\n* `\"declaration\"`: Enforces that type imports are all in the 'declaration'\n  style.\n\nThis rule has an object option:\n\n* `ignoreTypeDefault` - if `true`, when in \"identifier\" mode, default type imports will be ignored. Default is `false`.\n\nThe following patterns are considered problems:\n\n```js\nimport type {A, B} from 'a';\n// Message: Unexpected \"import type\"\n\n// Options: [\"identifier\"]\nimport type {A, B} from 'a';\n// Message: Unexpected \"import type\"\n\n// Options: [\"identifier\"]\nimport type {A, B as C} from 'a';\n// Message: Unexpected \"import type\"\n\n// Options: [\"identifier\"]\nimport type A from 'a';\n// Message: Unexpected \"import type\"\n\n// Options: [\"declaration\"]\nimport {type A, type B} from 'a';\n// Message: Unexpected type import\n// Message: Unexpected type import\n```\n\nThe following patterns are not considered problems:\n\n```js\nimport {type A, type B} from 'a';\n\n// Options: [\"identifier\"]\nimport {type A, type B} from 'a';\n\n// Options: [\"declaration\"]\nimport type {A, B} from 'a';\n\n// Options: [\"identifier\"]\nimport typeof * as A from 'a';\n\n// Options: [\"identifier\",{\"ignoreTypeDefault\":true}]\nimport type A from 'a';\n\n// Options: [\"identifier\"]\ndeclare module \"m\" { import type A from 'a'; }\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-union-intersection-spacing\"></a>\n### <code>union-intersection-spacing</code>\n\n_The `--fix` option on the command line automatically fixes problems reported by this rule._\n\nEnforces consistent spacing around union and intersection type separators (`|` and `&`).\n\nThis rule takes one argument. If it is `'always'` then a problem is raised when there is no space around the separator. If it is `'never'` then a problem is raised when there is a space around the separator.\n\nThe default value is `'always'`.\n\nThe following patterns are considered problems:\n\n```js\ntype X = string| number;\n// Message: There must be a space before union type annotation separator\n\n// Options: [\"always\"]\ntype X = string| number;\n// Message: There must be a space before union type annotation separator\n\ntype X = string |number;\n// Message: There must be a space after union type annotation separator\n\ntype X = string|number;\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n\ntype X = {x: string}|{y: number};\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n\ntype X = string | number |boolean;\n// Message: There must be a space after union type annotation separator\n\ntype X = string|number|boolean;\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n\ntype X = (string)| number;\n// Message: There must be a space before union type annotation separator\n\ntype X = ((string))|(number | foo);\n// Message: There must be a space before union type annotation separator\n// Message: There must be a space after union type annotation separator\n\n// Options: [\"never\"]\ntype X = string |number;\n// Message: There must be no space before union type annotation separator\n\n// Options: [\"never\"]\ntype X = string| number;\n// Message: There must be no space after union type annotation separator\n\ntype X = string& number;\n// Message: There must be a space before intersection type annotation separator\n\n// Options: [\"always\"]\ntype X = string& number;\n// Message: There must be a space before intersection type annotation separator\n\ntype X = string &number;\n// Message: There must be a space after intersection type annotation separator\n\ntype X = {x: string}&{y: number};\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n\ntype X = string&number;\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n\ntype X = string & number &boolean;\n// Message: There must be a space after intersection type annotation separator\n\ntype X = string&number&boolean;\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n\ntype X = (string)& number;\n// Message: There must be a space before intersection type annotation separator\n\ntype X = ((string))&(number & foo);\n// Message: There must be a space before intersection type annotation separator\n// Message: There must be a space after intersection type annotation separator\n\n// Options: [\"never\"]\ntype X = string &number;\n// Message: There must be no space before intersection type annotation separator\n\n// Options: [\"never\"]\ntype X = string& number;\n// Message: There must be no space after intersection type annotation separator\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype X = string | number;\n\ntype X = string | number | boolean;\n\ntype X = (string) | number;\n\ntype X = ((string)) | (number | foo);\n\n// Options: [\"never\"]\ntype X = string|number\n\ntype X =\n| string\n| number\n\nfunction x() {\ntype X =\n| string\n| number\n}\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype X = string| number;\n\ntype X = string & number;\n\ntype X = string & number & boolean;\n\ntype X = (string) & number;\n\ntype X = ((string)) & (number & foo);\n\n// Options: [\"never\"]\ntype X = string&number\n\ntype X =\n& string\n& number\n\nfunction x() {\ntype X =\n& string\n& number\n}\n\n// Settings: {\"flowtype\":{\"onlyFilesWithFlowAnnotation\":true}}\ntype X = string& number;\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-use-flow-type\"></a>\n### <code>use-flow-type</code>\n\nMarks Flow [type alias](https://flowtype.org/docs/type-aliases.html) declarations as used.\n\nUsed to suppress [`no-unused-vars`](http://eslint.org/docs/rules/no-unused-vars) errors that are triggered by type aliases.\n\nThe following patterns are not considered problems:\n\n```js\ndeclare class A {}\n// Additional rules: {\"no-unused-vars\":1}\n\ndeclare function A(): Y\n// Additional rules: {\"no-unused-vars\":1}\n\ndeclare module A {}\n// Additional rules: {\"no-unused-vars\":1}\n\ndeclare module A { declare var a: Y }\n// Additional rules: {\"no-unused-vars\":1}\n\ndeclare var A: Y\n// Additional rules: {\"no-unused-vars\":1}\n\nimport type A from \"a\"; type X<B = ComponentType<A>> = { b: B }; let x: X; console.log(x);\n// Additional rules: {\"no-unused-vars\":1}\n\nimport type A from \"a\"; type X<B = A<string>> = { b: B }; let x: X; console.log(x);\n// Additional rules: {\"no-unused-vars\":1}\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-use-read-only-spread\"></a>\n### <code>use-read-only-spread</code>\n\nWarns against accidentally creating an object which is no longer read-only because of how spread operator works in Flow. Imagine the following code:\n\n```flow js\ntype INode = {|\n  +type: string,\n|};\n\ntype Identifier = {|\n  ...INode,\n  +name: string,\n|};\n```\n\nYou might expect the identifier name to be read-only, however, that's not true ([flow.org/try](https://flow.org/try/#0C4TwDgpgBAkgcgewCbQLxQN4B8BQUoDUokAXFAM7ABOAlgHYDmANDlgL4DcOOx0MKdYDQBmNCFSjpseKADp58ZBBb4CdAIYBbCGUq1GLdlxwBjBHUpQAHmX4RBIsRKlQN2sgHIPTKL08eoTm4rWV5JKA8AZQALBABXABskVwRgKAAjaAB3WmB1dISIAEIPLhC3NAiY+KSUtMyoHJo8guLSnCA)):\n\n```flow js\nconst x: Identifier = { name: '', type: '' };\n\nx.type = 'must NOT be writable!'; // No Flow error\nx.name = 'must NOT be writable!'; // No Flow error\n```\n\nThis rule suggests to use `$ReadOnly<>` to prevent accidental loss of readonly-ness:\n\n```flow js\ntype Identifier = $ReadOnly<{|\n  ...INode,\n  +name: string,\n|}>;\n\nconst x: Identifier = { name: '', type: '' };\n\nx.type = 'must NOT be writable!'; // $FlowExpectedError[cannot-write]\nx.name = 'must NOT be writable!'; // $FlowExpectedError[cannot-write]\n```\n\nThe following patterns are considered problems:\n\n```js\ntype INode = {||};\ntype Identifier = {|\n  ...INode,\n  +aaa: string,\n|};\n// Message: Flow type with spread property and all readonly properties must be wrapped in '$ReadOnly<>' to prevent accidental loss of readonly-ness.\n\ntype INode = {||};\ntype Identifier = {|\n  ...INode,\n  +aaa: string,\n  +bbb: string,\n|};\n// Message: Flow type with spread property and all readonly properties must be wrapped in '$ReadOnly<>' to prevent accidental loss of readonly-ness.\n```\n\nThe following patterns are not considered problems:\n\n```js\ntype INode = {||};\ntype Identifier = {|\n  ...INode,\n  name: string,\n|};\n\ntype INode = {||};\ntype Identifier = {|\n  ...INode,\n  name: string, // writable on purpose\n  +surname: string,\n|};\n\ntype Identifier = {|\n  +name: string,\n|};\n\ntype INode = {||};\ntype Identifier = $ReadOnly<{|\n  ...INode,\n  +name: string,\n|}>;\n\ntype INode = {||};\ntype Identifier = $ReadOnly<{|\n  ...INode,\n  name: string, // writable on purpose\n|}>;\n\ntype INode = {||};\ntype Identifier = $ReadOnly<{|\n  ...INode,\n  -name: string,\n|}>;\n```\n\n\n\n<a name=\"eslint-plugin-flowtype-rules-valid-syntax\"></a>\n### <code>valid-syntax</code>\n\n**Deprecated** Babylon (the Babel parser) v6.10.0 fixes parsing of the invalid syntax this plugin warned against.\n\nChecks for simple Flow syntax errors.\n\nThe following patterns are not considered problems:\n\n```js\nfunction x(foo: string = \"1\") {}\n\nfunction x(foo: Type = bar()) {}\n```\n\n\n\n",
    "licenseText": "Copyright (c) 2015, Gajus Kuizinas (http://gajus.com/)\nAll rights reserved.\n\nRedistribution and use in source and binary forms, with or without\nmodification, are permitted provided that the following conditions are met:\n    * Redistributions of source code must retain the above copyright\n      notice, this list of conditions and the following disclaimer.\n    * Redistributions in binary form must reproduce the above copyright\n      notice, this list of conditions and the following disclaimer in the\n      documentation and/or other materials provided with the distribution.\n    * Neither the name of the Gajus Kuizinas (http://gajus.com/) nor the\n      names of its contributors may be used to endorse or promote products\n      derived from this software without specific prior written permission.\n\nTHIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\" AND\nANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED\nWARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE\nDISCLAIMED. IN NO EVENT SHALL ANUARY BE LIABLE FOR ANY\nDIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES\n(INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;\nLOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND\nON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT\n(INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS\nSOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n"
  },
  "artifacts": [],
  "remote": {
    "resolved": "https://registry.yarnpkg.com/eslint-plugin-flowtype/-/eslint-plugin-flowtype-8.0.3.tgz#e1557e37118f24734aa3122e7536a038d34a4912",
    "type": "tarball",
    "reference": "https://registry.yarnpkg.com/eslint-plugin-flowtype/-/eslint-plugin-flowtype-8.0.3.tgz",
    "hash": "e1557e37118f24734aa3122e7536a038d34a4912",
    "integrity": "sha512-dX8l6qUL6O+fYPtpNRideCFSpmWOUVx5QcaGLVqe/vlDiBSe4vYljDWDETwnyFzpl7By/WVIu6rcrniCgH9BqQ==",
    "registry": "npm",
    "packageName": "eslint-plugin-flowtype",
    "cacheIntegrity": "sha512-dX8l6qUL6O+fYPtpNRideCFSpmWOUVx5QcaGLVqe/vlDiBSe4vYljDWDETwnyFzpl7By/WVIu6rcrniCgH9BqQ== sha1-4VV+NxGPJHNKoxIudTagONNKSRI="
  },
  "registry": "npm",
  "hash": "e1557e37118f24734aa3122e7536a038d34a4912"
}